---
title: 面向对象进阶（多态、内部类、常用API）
date: 2023-03-08 20:17:52
permalink: /pages/a4fc75/
categories:
  - 开发
  - Java
  - 黑马Java入门基础-学习笔记
tags:
  -  
---

# 面向对象进阶（多态、内部类、常用 API）

## 1. 多态：面向对象三大特征之三

### 1.1 多态的概述、形式

- 啥是多态
  - 同一父类型的对象，执行同一个行为时，会表现出不同的行为特征。
- 多态的常见形式
  - `父类类型 对象名称 = new 子类构造器;` （父类类型指向一个子类的对象）
  - `接口    对象名称 = new 实现类构造器;`（接口相当于一个干爹，实现类相当于儿子）
  - 具体的行为方法在子类中重写
- 多态中成员访问特点- 
  - 方法调用：编译看左边，运行看<u>右边</u>。
  - 变量调用：编译看左边，运行也看<u>左边</u>。（多态侧重行为多态，变量没有多态的概念）
    - 即对于变量调用，还是会使用父类中的变量，而方法是会使用子类中重写的方法的。
- 多态的前提
  - 有继承/实现关系
  - 有父类引用指向子类对象
  - 有方法重写



### 1.2 多态的优势

1. 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。

```java
Animal a = new Dog();
a.run(); // 后续业务行为随对象而变，后续代码无需修改
```

​	上述代码中，若后续业务需要将 Dog 子类改为Tortoise 子类，则直接改“=”右侧的子类类型即可，后续代码中的行为随着对象的改变而直接变化了，无需修改很多后续的代码。

2. 定义方法的时候，<u>使用父类型作为参数</u>，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利

::: warning 多态下会产生的一个问题

多态下不能使用子类的独有功能，因为编译时会使用左侧的父类中的行为。

solve：使用强制类型转换，将父转为子类型。

:::

### 1.3 多态下引用数据类型的类型转换

在多态下会有两种类型转换：

- 自动类型转换（从子到父）
- 强制类型转换（从父到子）

**关于强制类型转换：**

- `子类类型 对象变量 = (子类)父类类型的变量`

  代码示例：

  ```java
  // 自动类型转换
  Animal a = new Dog();
  a.run();
  // 强制类型转换:可以实现调用子类独有功能的
  Dog d = (Dog) a;
  d.lookDoor();
  ```

- 作用：可以解决多态下的劣势，可以实现调用子类独有的功能

- 注意： 如果转型后的类型和对象真实类型不是同一种类型，那么在转换的时候就会报错 <font color="#dd0000">**ClassCastException（类型转换异常）** </font>

::: tip 强转转换的一点建议

规定：有继承或者实现关系的2个类型就可以强制类型转换，故编译时可能没问题，但运行时发现强制转换后的类型不是对象真实类型而报错。

Java 建议强转转换前使用 instanceof 判断当前对象的真实类型，再进行强制转换。

:::

**关于 instanceof 关键字的使用：**

`变量名 instanceof 真实类型`

判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则返回true，反之false。

代码示例：

```java
public static void go(Animal a){  // 参数类型为父类类型，保证各种动物都可以使用go方法
    System.out.println("预备~~~");
    a.run();
    // 独有功能
    if(a instanceof Tortoise){
        Tortoise t = (Tortoise) a;
        t.layEggs();
    }else if(a instanceof Dog){
        Dog d1 = (Dog) a;
        d1.lookDoor();
    }
    System.out.println("结束~~~~");
}
```

### 1.4 多态的案例

需求：设计一个电脑对象，可以安装2个USB设备。鼠标：被安装时可以完成接入、调用点击功能、拔出功能；键盘：被安装时可以完成接入、调用打字功能、拔出功能。

分析：

①定义一个USB的接口（申明USB设备的规范必须是：可以接入和拔出）。

②提供2个USB实现类代表鼠标和键盘，让其实现USB接口，并分别定义独有功能。

③创建电脑对象，创建2个USB实现类对象，分别安装到电脑中并触发功能的执行。



## 2. 内部类

 ### 2.1 内部类的概述

内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。

如，心脏和人的关系：

```java
public class People{
    // 内部类
    public class Heart{
    }
}
```

### 2.2 **内部类的使用场景、作用**

- 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。
- 内部类通常可以方便访问外部类的成员，包括私有的成员。
- 内部类提供了更好的封装性，内部类本身就可以用 private、protected 等修饰，封装性可以做更多控制。（外部类只能用 public 修饰）

### 2.3 内部类的分类

#### 2.3.1 静态内部类

- 有static修饰，属于外部类本身
- 特点、使用与普通类是一样的，类有的成分它都有，只是位置在别人里面而已
- 可以直接访问外部类的静态成员，<u>不能**直接**访问外部类的实例成员</u>（可以创建一个外部类对象，再访问其实例成员）
- 注意：开发中实际上用的还是比较少
- 定义示例：

```java
public class Outer{
        // 静态成员内部类
    public static class Inner{
    }
}
```

- 创建对象的格式：`Outer.Inner in =  new Outer.Inner();`

#### 2.3.2 成员内部类

- 无 static 修饰，属于外部类的对象
- JDK16 之前，成员内部类中不能定义静态成员，JDK 16 开始也可以定义静态成员了
- 特点：可以直接访问外部类的静态成员，实例方法中<u>可以**直接**访问外部类的实例成员</u>（因为必须先有外部类对象，才能有成员内部类对象，所以可以直接访问外部类对象的实例成员）
- 定义示例：

```java
public class Outer {
    // 成员内部类
    public class Inner {        
    }
}
```

- 创建对象格式：`Outer.Inner in =  new Outer().new Inner();` （注意外部类对象后面要加() ）
- **相关面试题：**
  - 在成员内部类中访问所在外部类对象，格式：`外部类名.this.value`，如：`System.out.println(People.this.heartbeat);`
  - 访问当前对象的成员变量，要用 `this.value`

#### 2.3.3 局部内部类

- **鸡肋语法，了解即可**
- 局部内部类放在方法、代码块、构造器等执行体中
- 局部内部类编译后也会有对应的类文件，其类文件名为： 外部类$N内部类.class

#### 2.3.4 匿名内部类

- 本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等
- **作用**：方便创建子类对象，最终目的为了简化代码编写

- 特点
  - 匿名内部类写出来就会产生一个匿名内部类的对象
  - 匿名内部类的对象类型相当于是当前 new 的那个的类型的子类类型（可以视为是 Animal 的子类 Tiger 类）

- 格式

```java
new 类|抽象类名|或者接口名() {
    重写方法;
};
```

```java
Animal a = new Animal() {
    public void run() {
    }
};
a. run();
```

:warning: 直接 `new abstract_class()` 是不可以的，故后面加上 {} 进行方法的重写，实现一个匿名内部类。

简单示例：

line3 等号后 ~ line8 的部分相当于 Tiger 类了。

```java
public class Test {
    public static void main(String[] args) {
        Animal a = new Animal(){
            @Override
            public void run() {
                System.out.println("老虎跑的块~~~");
            }
        };
        a.run();
    }
}

//class Tiger extends Animal{
//    @Override
//    public void run() {
//        System.out.println("老虎跑的块~~~");
//    }
//}

abstract class Animal{
    public abstract void run();
}
```

#### 2.3.5 匿名内部类常见使用形式 

匿名内部类通常作为方法的实际参数进行传输。

示例代码：

```java
public class Test2 {
    public static void main(String[] args) {
        
        go(new Swimming() {
            @Override
            public void swim() {
                System.out.println("运动员泳🏊的贼快~~~~~");
            }
        });

    /**
       学生 老师 运动员可以一起参加游泳比赛
     */
    public static void go(Swimming s){
        System.out.println("开始。。。");
        s.swim();
        System.out.println("结束。。。");
    }
}
    
interface Swimming{
    void swim();
}
```

对象回调：

<img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/image-20230308222150352.png" alt="image-20230308222150352" style="zoom: 50%;" />

::: tip

开发中不是我们主动去定义匿名内部类的，而是别人需要我们写或者我们可以写的时候才会使用。

匿名内部类的代码可以实现代码进一步的简化。

:::



test!!!!! bynrich



























