<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>切片集群 | Nrich&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/blog/img/bitbug_favicon.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.5e70c998.css" as="style"><link rel="preload" href="/blog/assets/js/app.73302609.js" as="script"><link rel="preload" href="/blog/assets/js/2.c02cd514.js" as="script"><link rel="preload" href="/blog/assets/js/24.d04239a4.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ccc2fc76.js"><link rel="prefetch" href="/blog/assets/js/11.15e920f7.js"><link rel="prefetch" href="/blog/assets/js/12.d6b747fb.js"><link rel="prefetch" href="/blog/assets/js/13.ee8d04f3.js"><link rel="prefetch" href="/blog/assets/js/14.b7513ca5.js"><link rel="prefetch" href="/blog/assets/js/15.f2e8ff40.js"><link rel="prefetch" href="/blog/assets/js/16.347a6e24.js"><link rel="prefetch" href="/blog/assets/js/17.6c1e9625.js"><link rel="prefetch" href="/blog/assets/js/18.7602b54c.js"><link rel="prefetch" href="/blog/assets/js/19.8f4fcc4b.js"><link rel="prefetch" href="/blog/assets/js/20.09885064.js"><link rel="prefetch" href="/blog/assets/js/21.b525f277.js"><link rel="prefetch" href="/blog/assets/js/22.b9ed6df2.js"><link rel="prefetch" href="/blog/assets/js/23.523e5d22.js"><link rel="prefetch" href="/blog/assets/js/25.237a6c47.js"><link rel="prefetch" href="/blog/assets/js/26.6bd9bfe4.js"><link rel="prefetch" href="/blog/assets/js/27.ac60ace0.js"><link rel="prefetch" href="/blog/assets/js/28.ee14024f.js"><link rel="prefetch" href="/blog/assets/js/29.0caa2b3a.js"><link rel="prefetch" href="/blog/assets/js/3.620a1f91.js"><link rel="prefetch" href="/blog/assets/js/30.e6e7d6f8.js"><link rel="prefetch" href="/blog/assets/js/31.6ec6039c.js"><link rel="prefetch" href="/blog/assets/js/32.37f8dd2f.js"><link rel="prefetch" href="/blog/assets/js/33.7e29804a.js"><link rel="prefetch" href="/blog/assets/js/34.8eeb5b9d.js"><link rel="prefetch" href="/blog/assets/js/35.72aa34f7.js"><link rel="prefetch" href="/blog/assets/js/36.9de84a28.js"><link rel="prefetch" href="/blog/assets/js/37.64e3dd13.js"><link rel="prefetch" href="/blog/assets/js/38.99ad5507.js"><link rel="prefetch" href="/blog/assets/js/39.8cda7b61.js"><link rel="prefetch" href="/blog/assets/js/4.0df20a49.js"><link rel="prefetch" href="/blog/assets/js/40.ed6949c0.js"><link rel="prefetch" href="/blog/assets/js/41.bf343b6b.js"><link rel="prefetch" href="/blog/assets/js/42.cbbfd0d9.js"><link rel="prefetch" href="/blog/assets/js/43.39209b19.js"><link rel="prefetch" href="/blog/assets/js/44.7eec5b18.js"><link rel="prefetch" href="/blog/assets/js/45.b088db4c.js"><link rel="prefetch" href="/blog/assets/js/46.bfc9e511.js"><link rel="prefetch" href="/blog/assets/js/47.d0b2aa80.js"><link rel="prefetch" href="/blog/assets/js/48.49b8f1b4.js"><link rel="prefetch" href="/blog/assets/js/49.72f6d0a1.js"><link rel="prefetch" href="/blog/assets/js/5.94069b5e.js"><link rel="prefetch" href="/blog/assets/js/50.dcbe6aa5.js"><link rel="prefetch" href="/blog/assets/js/51.cca2da80.js"><link rel="prefetch" href="/blog/assets/js/52.063ad237.js"><link rel="prefetch" href="/blog/assets/js/53.65573113.js"><link rel="prefetch" href="/blog/assets/js/54.e3b86f9a.js"><link rel="prefetch" href="/blog/assets/js/55.e23d17b7.js"><link rel="prefetch" href="/blog/assets/js/56.c47badfb.js"><link rel="prefetch" href="/blog/assets/js/57.8c7d3e16.js"><link rel="prefetch" href="/blog/assets/js/58.52fb51c8.js"><link rel="prefetch" href="/blog/assets/js/59.8ee7423a.js"><link rel="prefetch" href="/blog/assets/js/6.90726693.js"><link rel="prefetch" href="/blog/assets/js/60.7c6906fd.js"><link rel="prefetch" href="/blog/assets/js/61.898384c1.js"><link rel="prefetch" href="/blog/assets/js/62.6bf3cdda.js"><link rel="prefetch" href="/blog/assets/js/63.fed7f6ff.js"><link rel="prefetch" href="/blog/assets/js/64.62128c79.js"><link rel="prefetch" href="/blog/assets/js/65.dd8213b3.js"><link rel="prefetch" href="/blog/assets/js/66.579f1a82.js"><link rel="prefetch" href="/blog/assets/js/67.fa647f5d.js"><link rel="prefetch" href="/blog/assets/js/68.d535a10d.js"><link rel="prefetch" href="/blog/assets/js/69.4d7e0d52.js"><link rel="prefetch" href="/blog/assets/js/7.ba20b3c7.js"><link rel="prefetch" href="/blog/assets/js/70.4b6cd449.js"><link rel="prefetch" href="/blog/assets/js/71.be36a223.js"><link rel="prefetch" href="/blog/assets/js/72.f57cde07.js"><link rel="prefetch" href="/blog/assets/js/73.a4087adf.js"><link rel="prefetch" href="/blog/assets/js/74.8f60ef05.js"><link rel="prefetch" href="/blog/assets/js/75.fdc945ab.js"><link rel="prefetch" href="/blog/assets/js/76.d1f1faa5.js"><link rel="prefetch" href="/blog/assets/js/77.687a6763.js"><link rel="prefetch" href="/blog/assets/js/78.97f56bb1.js"><link rel="prefetch" href="/blog/assets/js/79.35c1de5f.js"><link rel="prefetch" href="/blog/assets/js/8.2abb0131.js"><link rel="prefetch" href="/blog/assets/js/80.fbe50656.js"><link rel="prefetch" href="/blog/assets/js/81.102e33bc.js"><link rel="prefetch" href="/blog/assets/js/82.4f73285b.js"><link rel="prefetch" href="/blog/assets/js/9.ece9abdb.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5e70c998.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/mylogo.jpeg" alt="Nrich's blog" class="logo"> <span class="site-name can-hide">Nrich's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><!----> <span class="title" style="display:;">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">Golang</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AI" class="dropdown-title"><!----> <span class="title" style="display:;">AI</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/deep-learning/" class="nav-link">深度学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/blog/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/datastructure/" class="nav-link">DataStructure</a></li><li class="dropdown-item"><!----> <a href="/blog/cloudnative/" class="nav-link">CloudNative</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><!----> <span class="title" style="display:;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/blog/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><!----> <span class="title" style="display:;">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/route-hijack/" class="nav-link">路由劫持</a></li></ul></div></div> <a href="https://github.com/n7301/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/head.jpg"> <div class="blogger-info"><h3>Nrich</h3> <span>小聪明</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><!----> <span class="title" style="display:;">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">Golang</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AI" class="dropdown-title"><!----> <span class="title" style="display:;">AI</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/deep-learning/" class="nav-link">深度学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/blog/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/datastructure/" class="nav-link">DataStructure</a></li><li class="dropdown-item"><!----> <a href="/blog/cloudnative/" class="nav-link">CloudNative</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><!----> <span class="title" style="display:;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/blog/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><!----> <span class="title" style="display:;">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/route-hijack/" class="nav-link">路由劫持</a></li></ul></div></div> <a href="https://github.com/n7301/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>专栏：Redis 核心技术与实战</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/271391/" class="sidebar-link">基础架构、数据结构与 IO 模型</a></li><li><a href="/blog/pages/d1a6d3/" class="sidebar-link">持久化机制：AOF日志和RDB快照</a></li><li><a href="/blog/pages/348567/" class="sidebar-link">主从复制与哨兵机制</a></li><li><a href="/blog/pages/71b166/" aria-current="page" class="active sidebar-link">切片集群</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/71b166/#_1-切片集群-数据增多了-是该加内存还是加实例" class="sidebar-link">1. 切片集群：数据增多了，是该加内存还是加实例？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_1-1-如何保存更多数据" class="sidebar-link">1.1 如何保存更多数据？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_1-2-数据切片和实例的对应分布关系" class="sidebar-link">1.2 数据切片和实例的对应分布关系</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_1-3-客户端如何定位数据" class="sidebar-link">1.3 客户端如何定位数据？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_1-4-小结" class="sidebar-link">1.4 小结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/71b166/#_2-codis-vs-redis-cluster-我该选择哪一个集群方案" class="sidebar-link">2. Codis VS Redis Cluster：我该选择哪一个集群方案？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_2-1-codis-的整体架构和基本流程" class="sidebar-link">2.1 Codis 的整体架构和基本流程</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_2-2-codis-的关键技术原理" class="sidebar-link">2.2 Codis 的关键技术原理</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/71b166/#_2-2-1-数据如何在集群里分布" class="sidebar-link">2.2.1 数据如何在集群里分布？</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/71b166/#_2-2-2-集群扩容和数据迁移如何进行" class="sidebar-link">2.2.2 集群扩容和数据迁移如何进行?</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/71b166/#_2-2-3-客户端的兼容性" class="sidebar-link">2.2.3 客户端的兼容性</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/71b166/#_2-2-4-怎么保证集群可靠性" class="sidebar-link">2.2.4 怎么保证集群可靠性？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/71b166/#_2-3-切片集群方案选择建议" class="sidebar-link">2.3 切片集群方案选择建议</a></li></ul></li></ul></li><li><a href="/blog/pages/2029a8/" class="sidebar-link">Redis 中的数据结构</a></li><li><a href="/blog/pages/a3ed18/" class="sidebar-link">时间序列数据的保存</a></li><li><a href="/blog/pages/5d636a/" class="sidebar-link">Redis 的消息队列方案</a></li><li><a href="/blog/pages/ca62e3/" class="sidebar-link">异步机制、CPU 架构对性能的影响</a></li><li><a href="/blog/pages/f111bf/" class="sidebar-link">如何应对变慢的 Redis</a></li><li><a href="/blog/pages/6135bf/" class="sidebar-link">Redis 的内存碎片、缓冲区</a></li><li><a href="/blog/pages/d403e5/" class="sidebar-link">Redis 用作缓存</a></li><li><a href="/blog/pages/cbe81b/" class="sidebar-link">Redis 用作缓存之缓存异常</a></li><li><a href="/blog/pages/ea52c5/" class="sidebar-link">Redis 用作缓存之缓存污染</a></li><li><a href="/blog/pages/8f7740/" class="sidebar-link">Pika：基于SSD实现大容量Redis</a></li><li><a href="/blog/pages/5a1b01/" class="sidebar-link">无锁的原子操作和分布式锁</a></li><li><a href="/blog/pages/932816/" class="sidebar-link">Redis 的事务机制</a></li><li><a href="/blog/pages/4140fe/" class="sidebar-link">Redis 主从同步的坑</a></li><li><a href="/blog/pages/b6efd0/" class="sidebar-link">秒杀场景下的应用</a></li><li><a href="/blog/pages/d3d97d/" class="sidebar-link">集群的数据倾斜和通信开销问题</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/categories/?category=%E4%B8%AD%E9%97%B4%E4%BB%B6" title="分类" data-v-06225672>中间件</a></li><li data-v-06225672><a href="/blog/categories/?category=Redis" title="分类" data-v-06225672>Redis</a></li><li data-v-06225672><a href="/blog/categories/?category=%E4%B8%93%E6%A0%8F%EF%BC%9ARedis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98" title="分类" data-v-06225672>专栏：Redis 核心技术与实战</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/Nrich-sunny" target="_blank" title="作者" class="beLink" data-v-06225672>Nrich</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-03-27</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">切片集群<!----></h1>  <div class="theme-vdoing-content content__default"><blockquote><p>参考：</p> <ul><li><a href="https://time.geekbang.org/column/intro/100056701?tab=catalog" target="_blank" rel="noopener noreferrer">09 切片集群：数据增多了，是该加内存还是加实例？| 极客时间<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://time.geekbang.org/column/intro/100056701?tab=catalog9" target="_blank" rel="noopener noreferrer">35 Codis VS Redis Cluster：我该选择哪一个集群方案？| 极客时间<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote> <h2 id="_1-切片集群-数据增多了-是该加内存还是加实例"><a href="#_1-切片集群-数据增多了-是该加内存还是加实例" class="header-anchor">#</a> 1. 切片集群：数据增多了，是该加内存还是加实例？</h2> <p>有这么一个需求：要用 Redis 保存 5000 万个键值对，每个键值对大约是 512B，为了能快速部署并对外提供服务，我们采用云主机来运行 Redis 实例，那么，该如何选择云主机的内存容量呢？</p> <p>粗略计算一下，这些 KV 所占的内存空间大约为 25GB，所以第一反应是选择一台 32G 内存的云主机来部署 Redis。但在使用过程中会发现，Redis 响应有时会非常慢，这时使用 INFO 命令查看 Redis 的 latest_fork_usec 指标值（表示最近一次 fork 的耗时），结果显示这个指标值特别高，快到秒级别了。</p> <p>这跟 Redis 的持久化机制有关系。<strong>在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的</strong>，而 fork 在执行时会阻塞主线程。<strong>数据量越大，fork 操作造成的主线程阻塞的时间越长</strong>。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢了。</p> <p>看来，第一个方案显然是不可行的，我们必须要寻找其他的方案。这个时候，我们注意到了 Redis 的切片集群。虽然组建切片集群比较麻烦，但是它可以保存大量数据，而且对 Redis 主线程的阻塞影响较小。</p> <p><mark>切片集群</mark>，也叫分片集群，就是指启动<u>多个 Redis 实例组成一个集群</u>，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。回到我们刚刚的场景中，如果把 25GB 的数据平均分成 5 份（当然，也可以不做均分），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。如下图所示：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230327155046.png" alt="$uploadName" style="zoom:55%;"></center> <p>那么，在切片集群中，实例在为 5GB 数据生成 RDB 时，数据量就小了很多，fork 子进程一般不会给主线程带来较长时间的阻塞。<strong>采用多个实例保存数据切片后，我们既能保存 25GB 数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢</strong>。</p> <p>在实际应用 Redis 时，随着用户或业务规模的扩展，保存大量数据的情况通常是无法避免的。而切片集群，就是一个非常好的解决方案。这节课，我们就来学习一下。</p> <h3 id="_1-1-如何保存更多数据"><a href="#_1-1-如何保存更多数据" class="header-anchor">#</a> 1.1 如何保存更多数据？</h3> <p>在刚刚的案例里，为了保存大量数据，我们使用了大内存云主机和切片集群两种方法。实际上，这两种方法分别对应着 Redis 应对数据量增多的两种方案：纵向扩展和横向扩展：</p> <ul><li><mark>纵向扩展</mark>（<strong>scale up</strong>）：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。</li> <li><mark>横向扩展</mark>（<strong>scale out</strong>）：横向增加当前 Redis 实例的个数。</li></ul> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230327155825.png" alt="$uploadName" style="zoom:55%;"></center> <p>两种方式各有优缺点：</p> <ul><li><p>纵向扩展实施简单，但持久化 RDB 文件会显著降低性能，而且会受到硬件与成本的限制。</p> <ul><li>如果你不要求持久化保存Redis数据，那么，纵向扩展会是一个不错的选择。</li></ul></li> <li><p>横向扩展不需要担心硬件和成本的限制，但涉及到多实例的分布式管理的问题。</p> <ul><li>在面向百万、千万级别的用户规模时，横向扩展的Redis切片集群会是一个非常好的选择.</li></ul></li></ul> <p><u>要想把切片集群用起来，我们就需要解决两大问题</u>：</p> <ul><li>数据切片后，在多个实例之间如何分布？</li> <li>客户端怎么确定想要访问的数据在哪个实例上？</li></ul> <p>接下来，我们就一个个地解决。</p> <h3 id="_1-2-数据切片和实例的对应分布关系"><a href="#_1-2-数据切片和实例的对应分布关系" class="header-anchor">#</a> 1.2 数据切片和实例的对应分布关系</h3> <p>在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？这就和接下来我要讲的 Redis Cluster 方案有关了。不过，我们要先弄明白<u>切片集群和 Redis Cluster 的联系与区别</u>。</p> <p>实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 <mark>Redis Cluster</mark> 的方案，用于实现切片集群。<u>Redis Cluster 方案中就规定了数据和实例的对应规则</u>。</p> <p>具体来说，Redis Cluster 方案采用<strong>哈希槽</strong>（<mark>Hash Slot</mark>，后面称为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，<strong>每个键值对都会根据它的 key，被映射到一个 slot 中</strong>。<u>具体的映射过程分为两大步</u>：</p> <ul><li>首先根据键值对的 key，按照 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener noreferrer">CRC16 算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>计算一个 16bit 的值；</li> <li>然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的 slot。</li></ul> <p>那么，这些 slot 又是如何被映射到具体的 Redis 实例上的呢？我们在部署 Redis Cluster 方案时，可以使用 <code>cluster create</code> 命令创建集群，此时，<strong>Redis 会自动把这些 slot 平均分布在集群实例上</strong>。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。这也是 DDIA 中讲的数据分区方法中的固定逻辑分区的方法。</p> <p>当然， 我们也可以使用 <code>cluster meet</code> 命令手动建立实例间的连接，形成集群，再使用 <code>cluster addslots</code> 命令，根据不同实例的资源情况指定每个实例上的 slot 个数。下图展示了数据、哈希槽和实例这三者的映射分布情况：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230327162002.png" alt="$uploadName" style="zoom:75%;"></center> <p>示意图中的切片集群一共有 3 个实例，同时假设有 5 个 slot，我们首先可以通过下面的命令手动分配 slot：实例 1 保存 slot 0 和 1，实例 2 保存 slot 2 和 3，实例 3 保存 slot 4。配置命令如下：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>redis-cli <span class="token parameter variable">-h</span> <span class="token number">172.16</span>.19.3 –p <span class="token number">6379</span> cluster addslots <span class="token number">0,1</span>
redis-cli <span class="token parameter variable">-h</span> <span class="token number">172.16</span>.19.4 –p <span class="token number">6379</span> cluster addslots <span class="token number">2,3</span>
redis-cli <span class="token parameter variable">-h</span> <span class="token number">172.16</span>.19.5 –p <span class="token number">6379</span> cluster addslots <span class="token number">4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意：<strong>在手动分配 slot 时，需要把 16384 个 slot 都分配完，否则 Redis 集群无法正常工作</strong>。</p> <p>综上，通过哈希槽，切片集群就实现了数据到哈希槽、哈希槽再到实例的分配。但是，即使实例有了哈希槽的映射信息，<strong><u>客户端又是怎么知道要访问的数据在哪个实例上呢</u></strong>？</p> <h3 id="_1-3-客户端如何定位数据"><a href="#_1-3-客户端如何定位数据" class="header-anchor">#</a> 1.3 客户端如何定位数据？</h3> <p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，<strong>要进一步定位到 Redis 实例，还需要知道 slot 分布在哪个实例上</strong>。</p> <p>一般来说，<strong>客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端</strong>。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。那么，<u>客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢</u>？这是因为，<strong>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散</strong>。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p> <p><font color="red">客户端收到哈希槽信息后，会把哈希槽信息缓存在本地</font>。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。但是，<u>在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个</u>：</p> <ul><li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li> <li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li></ul> <p>此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了，那该怎么办呢？</p> <p>Redis Cluster 方案提供了一种<mark>重定向机制</mark>，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，如果这个实例上并没有相应的数据，实例就会想客户端返回一个如下所示的 <code>MOVED</code> 命令响应结果，客户端这时就要再给一个新实例发送操作命令。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>GET hello:key
(error) MOVED 13320 172.16.19.5:6379
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。</p> <p>下面用一张图来说明一下 MOVED 命令的重定向的使用方法。可以看到，由于负载均衡，Slot 2中的数据已经从实例2迁移到了实例3，但是，客户端缓存仍然记录着“Slot 2在实例2”的信息，所以会给实例2发送命令。实例2给客户端返回一条 <code>MOVED</code> 命令，把Slot 2的最新位置（也就是在实例3上），返回给客户端，客户端就会再次向实例3发送请求，同时还会更新本地缓存，把 Slot 2与实例的对应关系更新过来。</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230327163224.png" alt="$uploadName" style="zoom:75%;"></center> <p>需要注意的是，在上图中，当客户端给实例2发送命令时，Slot 2中的数据已经全部迁移到了实例3。在实际应用时，如果Slot 2中的数据比较多，就可能会出现一种情况：客户端向实例2发送请求，但此时，Slot 2中的数据只有一部分迁移到了实例3，还有部分数据没有迁移。<strong>在这种迁移部分完成的情况下，客户端就会收到一条 <code>ASK</code> 报错信息</strong>，如下所示：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>GET hello:key
(error) ASK 13320 172.16.19.5:6379
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。</p> <p>看起来好像有点复杂，我再借助图片来解释一下。在下图中，Slot 2正在从实例2往实例3迁移，key1和key2已经迁移过去，key3和key4还在实例2。客户端向实例2请求key2后，就会收到实例2返回的ASK命令。</p> <p><u>ASK 命令表示两层含义</u>：</p> <ul><li>第一，表明 slot 数据还在迁移中；</li> <li>第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令。</li></ul> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230327163247.png" alt="$uploadName" style="zoom:75%;"></center> <p>和 MOVED 命令不同，<strong><font color="red">ASK命令并不会更新客户端缓存的哈希槽分配信息</font></strong>。所以，在上图中，如果客户端再次请求 slot 2 中的数据，它还是会给 实例 2 发送请求。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。</p> <h3 id="_1-4-小结"><a href="#_1-4-小结" class="header-anchor">#</a> 1.4 小结</h3> <p>这节课，我们学习了切片集群在保存大量数据方面的优势，以及基于哈希槽的数据分布机制和客户端定位键值对的方法。</p> <p>在应对数据量扩容时，虽然增加内存这种纵向扩展的方法简单直接，但是会造成数据库的内存过大，导致性能变慢。Redis 切片集群提供了横向扩展的模式，也就是使用多个实例，并给每个实例配置一定数量的哈希槽，数据可以通过键的哈希值映射到哈希槽，再通过哈希槽分散保存到不同的实例上。这样做的好处是扩展性好，不管有多少数据，切片集群都能应对。</p> <p>另外，集群的实例增减，或者是为了实现负载均衡而进行的数据重新分布，会导致哈希槽和实例的映射关系发生变化，客户端发送请求时，会收到命令执行报错信息。了解了 MOVED 和 ASK 命令，你就不会为这类报错而头疼了。</p> <p>我刚刚说过，在 Redis 3.0 之前，Redis 官方并没有提供切片集群方案，但是，其实当时业界已经有了一些切片集群的方案，例如基于客户端分区的 ShardedJedis，基于代理的 Codis、Twemproxy 等。这些方案的应用早于 Redis Cluster 方案，在支撑的集群实例规模、集群稳定性、客户端友好性方面也都有着各自的优势，我会在后面的课程中，专门和你聊聊这些方案的实现机制，以及实践经验。这样一来，当你再碰到业务发展带来的数据量巨大的难题时，就可以根据这些方案的特点，选择合适的方案实现切片集群，以应对业务需求了。</p> <hr> <p><strong>本节问题：为什么Redis不直接用一个表，把键值对和实例的对应关系记录下来，而是要对键值对的 key 做 CRC 计算</strong>？</p> <p>如果使用表记录键值对和实例的对应关系，一旦键值对和实例的对应关系发生了变化（例如实例有增减或者数据重新分布），就要修改表。如果是单线程操作表，那么所有操作都要串行执行，性能慢；如果是多线程操作表，就涉及到加锁开销。此外，如果数据量非常大，使用表记录键值对和实例的对应关系，需要的额外存储空间也会增加。</p> <p>基于哈希槽计算时，虽然也要记录哈希槽和实例的对应关系，但是哈希槽的个数要比键值对的个数少很多，无论是修改哈希槽和实例的对应关系，还是使用额外空间存储哈希槽和实例的对应关系，都比直接记录键值对和实例的关系的开销小得多。</p> <h2 id="_2-codis-vs-redis-cluster-我该选择哪一个集群方案"><a href="#_2-codis-vs-redis-cluster-我该选择哪一个集群方案" class="header-anchor">#</a> 2. Codis VS Redis Cluster：我该选择哪一个集群方案？</h2> <p>前面学习了 Redis 官方提供的切片集群方案 Redis Cluster，但在该方案发布之前，业界已经广泛使用 Codis。这一节将讲解 Codis 的实现原理，并将两者进行对比，从而选出最佳的集群方案。</p> <h3 id="_2-1-codis-的整体架构和基本流程"><a href="#_2-1-codis-的整体架构和基本流程" class="header-anchor">#</a> 2.1 Codis 的整体架构和基本流程</h3> <p>Codis 集群中包含了 4 类关键组件：</p> <ul><li><strong>codis server</strong>：这是进行了二次开发的Redis实例，其中增加了额外的数据结构，支持数据迁移操作，主要负责处理具体的数据读写请求。</li> <li><strong>codis proxy</strong>：接收客户端请求，并把请求转发给codis server。</li> <li><strong>Zookeeper 集群</strong>：保存集群元数据，例如数据位置信息和codis proxy信息。这里，有个地方需要你注意，除了使用Zookeeper，Codis还可以使用etcd或本地文件系统保存元数据信息。</li> <li><strong>codis dashboard 和 codis fe</strong>：共同组成了集群管理工具。其中，codis dashboard负责执行集群管理工作，包括增删codis server、codis proxy和进行数据迁移。而codis fe负责提供dashboard的Web操作界面，便于我们直接在Web界面上进行集群管理。</li></ul> <p>我用一张图来展示下 Codis 集群的架构和关键组件：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421155803.png" alt="$uploadName" style="zoom:75%;"></center> <p>下面具体解释一下 <u>Codis 是如何处理请求的</u>：</p> <ul><li>首先，为了让集群能接收并处理请求，我们要先使用 codis dashboard 设置 codis server 和 codis proxy 的访问地址，完成设置后，codis server 和 codis proxy 才会开始接收连接。</li> <li>然后，当客户端要读写数据时，客户端直接和codis proxy建立连接。<strong>codis proxy 本身支持 Redis 的 RESP 交互协议</strong>，所以客户端访问codis proxy时，和访问原生的Redis实例没有什么区别，这样一来，原本连接单实例的客户端就可以轻松地和Codis集群建立起连接了。</li> <li>最后，codis proxy接收到请求，就会查询请求数据和codis server的映射关系，并把请求转发给相应的codis server进行处理。当codis server处理完请求后，会把结果返回给codis proxy，proxy再把数据返回给客户端。</li></ul> <p>用一张图来展示这个处理流程：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421160308.png" alt="$uploadName" style="zoom:75%;"></center> <h3 id="_2-2-codis-的关键技术原理"><a href="#_2-2-codis-的关键技术原理" class="header-anchor">#</a> 2.2 Codis 的关键技术原理</h3> <p>这里将围绕影响切片集群使用效果的 4 方面技术因素：数据分布、集群扩容和数据迁移、客户端兼容性、可靠性保证，来讨论它们的具体设计选择和原理。</p> <h4 id="_2-2-1-数据如何在集群里分布"><a href="#_2-2-1-数据如何在集群里分布" class="header-anchor">#</a> 2.2.1 数据如何在集群里分布？</h4> <p>在 Codis 集群中，一个数据应该保存在哪个codis server上，这是通过<mark>逻辑槽</mark>（<strong>Slot</strong>）映射来完成的，具体来说，总共分成两步：</p> <ol><li><strong>第一步</strong>，Codis集群一共有1024个Slot，编号依次是0到1023。我们可以把这些Slot手动分配给codis server，每个server上包含一部分Slot。当然，我们也可以让codis dashboard进行自动分配，例如，dashboard把1024个Slot在所有server上均分。</li> <li><strong>第二步</strong>，当客户端要读写数据时，会使用CRC32算法计算数据key的哈希值，并把这个哈希值对1024取模。而取模后的值，则对应Slot的编号。此时，根据第一步分配的Slot和server对应关系，我们就可以知道数据保存在哪个server上了。</li></ol> <p>这个过程如下图所示：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421160713.png" alt="$uploadName" style="zoom:75%;"></center> <p>数据key和Slot的映射关系是客户端在读写数据前直接通过CRC32计算得到的，而Slot和codis server的映射关系是通过分配完成的，所以就需要用一个存储系统保存下来，否则，如果集群有故障了，映射关系就会丢失。</p> <p>我们把Slot和codis server的映射关系称为<mark>数据路由表</mark>（简称路由表）。我们在codis dashboard上分配好路由表后，dashboard会把路由表发送给codis proxy，同时，dashboard也会把路由表保存在Zookeeper中。codis-proxy会把路由表缓存在本地，当它接收到客户端请求后，直接查询本地的路由表，就可以完成正确的请求转发了。下图展示了路由表的分配和使用过程：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421161056.png" alt="$uploadName" style="zoom:75%;"></center> <p><strong>在数据分片的实现方法上，Codis 和 Redis Cluster 很相似，都采用了 key 映射到 Slot、Slot 再分配到实例上的机制</strong>。但是，这里有一个<u>明显的区别</u>：</p> <ul><li>Codis中的路由表是我们通过codis dashboard分配和修改的，并被保存在Zookeeper集群中。一旦数据位置发生变化（例如有实例增减），路由表被修改了，codis dashbaord就会把修改后的路由表发送给codis proxy，proxy就可以根据最新的路由信息转发请求了。</li> <li>在Redis Cluster中，数据路由表是通过每个实例相互间的通信传递的，最后会在每个实例上保存一份。当数据路由信息发生变化时，就需要在所有实例间通过网络消息进行传递。所以，如果实例数量较多的话，就会消耗较多的集群网络资源。</li></ul> <p>数据分布解决了新数据写入时该保存在哪个server的问题，但是，当业务数据增加后，如果集群中的现有实例不足以保存所有数据，我们就需要对集群进行扩容。接下来，我们再来学习下Codis针对集群扩容的关键技术设计。</p> <h4 id="_2-2-2-集群扩容和数据迁移如何进行"><a href="#_2-2-2-集群扩容和数据迁移如何进行" class="header-anchor">#</a> 2.2.2 集群扩容和数据迁移如何进行?</h4> <p>Codis <strong>集群扩容</strong>包括了两方面：增加 codis server 和增加 codis proxy。</p> <hr> <p>我们先来看增加 codis server，这个过程主要涉及到两步操作：</p> <ol><li>启动新的 codis server，将它加入集群中；</li> <li>把部分数据迁移到新的 server。</li></ol> <p>需要注意的是，这里的<strong>数据迁移是一个重要的机制</strong>。Codis 集群按照 Slot 的粒度进行数据迁移，我们来看下迁移的基本流程：</p> <ol><li>在源server上，Codis从要迁移的Slot中随机选择一个数据，发送给目的server。</li> <li>目的server确认收到数据后，会给源server返回确认消息。这时，源server会在本地将刚才迁移的数据删除。</li> <li>第一步和第二步就是单个数据的迁移过程。Codis会不断重复这个迁移过程，直到要迁移的Slot中的数据全部迁移完成。</li></ol> <p>下图显示了数据迁移的流程：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421161530.png" alt="$uploadName" style="zoom:75%;"></center> <p>针对刚才介绍的<u>单个数据的迁移过程，Codis实现了两种迁移模式</u>，分别是同步迁移和异步迁移：</p> <ul><li><strong>同步迁移</strong>是指，在数据从源server发送给目的server的过程中，源server是阻塞的，无法处理新的请求操作。这种模式很容易实现，但是迁移过程中会涉及多个操作（包括数据在源server序列化、网络传输、在目的server反序列化，以及在源server删除），如果迁移的数据是一个bigkey，源server就会阻塞较长时间，无法及时处理用户请求。</li> <li>为了避免数据迁移阻塞源server，Codis实现的第二种迁移模式就是<strong>异步迁移</strong>。异步迁移的关键特点有两个：
<ul><li>第一个特点是，当源server把数据发送给目的server后，就可以处理其他请求操作了，不用等到目的server的命令执行完。而目的server会在收到数据并反序列化保存到本地后，给源server发送一个ACK消息，表明迁移完成。此时，源server在本地把刚才迁移的数据删除。在这个过程中，迁移的数据会被设置为只读，所以，源server上的数据不会被修改，<strong>自然也就不会出现“和目的server上的数据不一致”的问题了</strong>。</li> <li>第二个特点是，对于bigkey，异步迁移采用了<strong>拆分指令</strong>的方式进行迁移。具体来说就是，对bigkey中每个元素，用一条指令进行迁移，而不是把整个bigkey进行序列化后再整体传输。这种化整为零的方式，就避免了bigkey迁移时，因为要序列化大量数据而阻塞源server的问题。此外，当bigkey迁移了一部分数据后，如果Codis发生故障，就会导致bigkey的一部分元素在源server，而另一部分元素在目的server，这就破坏了迁移的原子性。所以，Codis会在目标server上，给bigkey的元素设置一个临时过期时间。如果迁移过程中发生故障，那么，目标server上的key会在过期后被删除，<strong>不会影响迁移的原子性</strong>。当正常完成迁移后，bigkey元素的临时过期时间会被删除。</li></ul></li></ul> <blockquote><p>这里，有个地方需要你注意下，为了提升迁移的效率，Codis在异步迁移Slot时，允许每次迁移多个key。<strong>你可以通过异步迁移命令<code>SLOTSMGRTTAGSLOT-ASYNC</code>的参数numkeys设置每次迁移的key数量</strong>。</p></blockquote> <hr> <p>刚刚讲的是 codis server 的扩容和数据迁移机制，除此之外，我们可能还需要增加 codis proxy。因为在 Codis 集群中，客户端是和 codis proxy 直接连接的，所以，<strong>当客户端增加时，一个proxy无法支撑大量的请求操作，此时，我们就需要增加proxy</strong>。</p> <p>增加proxy比较容易，我们直接启动proxy，再通过codis dashboard把proxy加入集群就行。</p> <p>此时，codis proxy的访问连接信息都会保存在Zookeeper上。所以，当新增了proxy后，Zookeeper上会有最新的访问列表，客户端也就可以从Zookeeper上读取proxy访问列表，把请求发送给新增的proxy。这样一来，客户端的访问压力就可以在多个proxy上分担处理了，如下图所示：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421162056.png" alt="$uploadName" style="zoom:75%;"></center> <p>好了，到这里，我们就了解了Codis集群中的数据分布、集群扩容和数据迁移的方法，这都是切片集群中的关键机制。</p> <h4 id="_2-2-3-客户端的兼容性"><a href="#_2-2-3-客户端的兼容性" class="header-anchor">#</a> 2.2.3 客户端的兼容性</h4> <p>使用 Redis 单实例时，客户端只要符合 RESP 协议，就可以和实例进行交互和读写数据。但是，在使用切片集群时，有些功能是和单实例不一样的，比如集群中的数据迁移操作，在单实例上是没有的，而且迁移过程中，数据访问请求可能要被重定向（例如Redis Cluster中的MOVE命令）。所以，客户端需要增加和集群功能相关的命令操作的支持。如果原来使用单实例客户端，想要扩容使用集群，就需要使用新客户端，这对于业务应用的兼容性来说，并不是特别友好。</p> <blockquote><p>所以对于使用切片集群 Redis Cluster 而言，要想从单实例扩容成集群，就需要从单实例客户端换成新的客户端，对业务应用的兼容性而言，不是很友好。</p></blockquote> <p><strong>Codis 集群在设计时，就充分考虑了对现有单实例客户端的兼容性</strong>。Codis 使用 codis proxy 直接和客户端连接，codis proxy 是和单实例客户端兼容的。而和集群相关的管理工作（例如请求转发、数据迁移等），都由 codis proxy、codis dashboard 这些组件来完成，不需要客户端参与。</p> <p>这样一来，<font color="blue">业务应用使用 Codis 集群时，就不用修改客户端了，可以复用和单实例连接的客户端</font>，既能利用集群读写大容量数据，又避免了修改客户端增加复杂的操作逻辑，保证了业务代码的稳定性和兼容性。</p> <h4 id="_2-2-4-怎么保证集群可靠性"><a href="#_2-2-4-怎么保证集群可靠性" class="header-anchor">#</a> 2.2.4 怎么保证集群可靠性？</h4> <p><strong>对于一个分布式系统来说，它的可靠性和系统中的组件个数有关：组件越多，潜在的风险点也就越多</strong>。和Redis Cluster只包含Redis实例不一样，Codis集群包含的组件有4类。那你就会问了，这么多组件会降低Codis集群的可靠性吗？</p> <p>我们来分别看下 Codis 不同组件的可靠性保证方法。</p> <hr> <p>首先是 codis server。</p> <p>codis server其实就是Redis实例，只不过增加了和集群操作相关的命令。Redis的主从复制机制和哨兵机制在codis server上都是可以使用的，所以，Codis就使用主从集群来保证codis server的可靠性。简单来说就是，Codis给每个server配置从库，并使用哨兵机制进行监控，当发生故障时，主从库可以进行切换，从而保证了server的可靠性。</p> <p>在这种配置情况下，每个server就成为了一个server group，每个group中是一主多从的server。数据分布使用的Slot，也是按照group的粒度进行分配的。同时，codis proxy在转发请求时，也是按照数据所在的Slot和group的对应关系，把写请求发到相应group的主库，读请求发到group中的主库或从库上。</p> <p>下图展示的是配置了server group的Codis集群架构。在Codis集群中，我们通过部署server group和哨兵集群，实现codis server的主从切换，提升集群可靠性：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421162822.png" alt="$uploadName" style="zoom:75%;"></center> <hr> <p>再看一下 codis proxy 和 Zookeeper 的可靠性。这俩组件是搭配使用的。</p> <p>在Codis集群设计时，proxy上的信息源头都是来自Zookeeper（例如路由表）。而Zookeeper集群使用多个实例来保存数据，只要有超过半数的Zookeeper实例可以正常工作， Zookeeper集群就可以提供服务，也可以保证这些数据的可靠性。</p> <p>所以，codis proxy使用Zookeeper集群保存路由表，可以充分利用Zookeeper的高可靠性保证来确保codis proxy的可靠性，不用再做额外的工作了。<strong>当codis proxy发生故障后，直接重启proxy就行</strong>。重启后的proxy，可以通过codis dashboard从Zookeeper集群上获取路由表，然后，就可以接收客户端请求进行转发了。这样的设计，也降低了Codis集群本身的开发复杂度。</p> <hr> <p>对于codis dashboard和codis fe来说，它们主要提供配置管理和管理员手工操作，负载压力不大，所以，它们的可靠性可以不用额外进行保证了。</p> <h3 id="_2-3-切片集群方案选择建议"><a href="#_2-3-切片集群方案选择建议" class="header-anchor">#</a> 2.3 切片集群方案选择建议</h3> <p>下图总结了 Codis 和 Redis Cluster 两种切片集群方案，对比如下：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230421163032.png" alt="$uploadName" style="zoom:75%;"></center> <p>最后，在实际应用的时候，对于这两种方案的选择有如下建议：</p> <ol><li><p>从稳定性和成熟度来看，Codis应用得比较早，在业界已经有了成熟的生产部署。虽然Codis引入了proxy和Zookeeper，增加了集群复杂度，但是，proxy的无状态设计和Zookeeper自身的稳定性，也给Codis的稳定使用提供了保证。而Redis Cluster的推出时间晚于Codis，相对来说，成熟度要弱于Codis，如果你想选择一个成熟稳定的方案，Codis更加合适些。</p></li> <li><p>从业务应用客户端兼容性来看，连接单实例的客户端可以直接连接codis proxy，而原本连接单实例的客户端要想连接Redis Cluster的话，就需要开发新功能。所以，如果你的业务应用中大量使用了单实例的客户端，而现在想应用切片集群的话，建议你选择Codis，这样可以避免修改业务应用中的客户端。</p></li> <li><p>从使用Redis新命令和新特性来看，Codis server是基于开源的Redis 3.2.8开发的，所以，Codis并不支持Redis后续的开源版本中的新增命令和数据类型。另外，Codis并没有实现开源Redis版本的所有命令，比如BITOP、BLPOP、BRPOP，以及和与事务相关的MUTLI、EXEC等命令。 <a href="https://github.com/CodisLabs/codis/blob/release3.2/doc/unsupported_cmds.md" target="_blank" rel="noopener noreferrer">Codis官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 上列出了不被支持的命令列表，你在使用时记得去核查一下。所以，如果你想使用开源Redis 版本的新特性，Redis Cluster是一个合适的选择。</p></li> <li><p>从数据迁移性能维度来看，Codis能支持异步迁移，异步迁移对集群处理正常请求的性能影响要比使用同步迁移的小。所以，如果你在应用集群时，数据迁移比较频繁的话，Codis是个更合适的选择。</p></li></ol> <p>另外这里再提供一个 Codis 使用上的小建议：当你有多条业务线要使用 Codis 时，可以启动多个 codis dashboard，每个 dashboard 管理一部分 codis server，同时，再用一个 dashboard 对应负责一个业务线的集群管理，<strong>这样就可以做到用一个 Codis 集群实现多条业务线的隔离管理了</strong>。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/n7301/blog/edit/master/docs/中间件/05.Redis/05.专栏：Redis 核心技术与实战/09.切片集群.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/04/21, 08:38:32</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/348567/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">主从复制与哨兵机制</div></a> <a href="/blog/pages/2029a8/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redis 中的数据结构</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/348567/" class="prev">主从复制与哨兵机制</a></span> <span class="next"><a href="/blog/pages/2029a8/">Redis 中的数据结构</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/c0d84b/"><div>
            YAML、Pod、Job、CronJob、ConfigMap、Secret
            <!----></div></a> <span class="date">06-06</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/757154/"><div>
            Kubernetes 的安装与基本架构
            <!----></div></a> <span class="date">06-04</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/1cc8db/"><div>
            初识容器
            <!----></div></a> <span class="date">05-30</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/Nrich-sunny" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>Nrich | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/blog/assets/js/app.73302609.js" defer></script><script src="/blog/assets/js/2.c02cd514.js" defer></script><script src="/blog/assets/js/24.d04239a4.js" defer></script>
  </body>
</html>
