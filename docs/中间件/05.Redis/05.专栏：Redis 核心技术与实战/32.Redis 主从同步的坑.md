---
title: Redis 主从同步的坑
date: 2023-04-19 10:35:28
permalink: /pages/4140fe/
categories:
  - 中间件
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> - [32 Redis 主从同步与故障切换，有哪些坑？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog9)
> - [33 脑裂：一次奇怪的数据丢失| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog9)

## 1. Redis 主从同步与故障切换，有哪些坑？

Redis 的主从同步机制不仅可以让从库服务更多的读请求，分担主库的压力，而且还能在主库发生故障时，进行主从库切换，提供高可靠服务。不过在使用主从机制时可能会遇到一些坑，这里主要介绍三个坑：主从数据不一致、读到过期数据，以及配置项设置得不合理从而导致服务挂掉。

### 1.1 主从数据不一致

<mark>主从数据不一致</mark>，就是指客户端从从库中读取到的值和主库中的最新值并不一致。

出现的原因就是主从之间的数据复制是异步进行的。从库出现滞后的两个主要原因：

1. 网络延迟
2. 从库因其他操作而阻塞较长时间

应对方法主要有两个：

1. **硬件方面，尽量保证主从库间的网络状况良好**。例如，我们要避免把主从库部署在不同的机房，或者是避免把网络通信密集的应用（例如数据分析应用）和Redis主从库部署在一起。
2. **还可以开发一个外部程序来监控主从库间的复制进度**。下面介绍方法。

因为Redis的INFO replication命令可以查看主库接收写命令的进度信息（master\_repl\_offset）和从库复制写命令的进度信息（slave\_repl\_offset），所以，我们就可以开发一个监控程序，先用INFO replication命令查到主、从库的进度，然后，我们用master\_repl\_offset减去slave\_repl\_offset，这样就能得到从库和主库间的复制进度差值了。

<font color=blue>如果某个从库的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从库连接进行数据读取，这样就可以减少读到不一致数据的情况</font>。不过，**为了避免出现客户端和所有从库都不能连接的情况，我们需要把复制进度差值的阈值设置得大一些**。
当然，监控程序可以一直监控着从库的复制进度，当从库的复制进度又赶上主库时，我们就允许客户端再次跟这些从库连接。

### 1.2 读取过期数据

我们在使用 Redis 主从集群时，有时会读到过期数据。例如，数据 X 的过期时间是 202010240900，但是客户端在 202010240910 时，仍然可以从从库中读到数据 X。一个数据过期后，应该是被删除的，客户端不能再读取到该数据，但是，Redis 为什么还能在从库中读到过期的数据呢？

**其实，这个问题是由Redis的过期数据删除策略引起的**。

Redis 同时使用了两种策略来删除过期数据：

1. <mark>惰性删除策略</mark>：当一个数据的过期时间到了以后，并不会立即删除数据，而是等到再有请求来读写这个数据时，对数据进行检查，如果发现数据已经过期了，再删除这个数据。
   - 这种方法减少了删除数据对 CPU 资源的使用，但会导致大量已过期数据留在内存中。
2. <mark>定期删除策略</mark>：Redis 每隔一段时间（默认100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除，这样就可以及时释放一些内存。

清楚了这两个删除策略，我们再来看看它们为什么会导致读取到过期数据。

- 定期删除策略只会随机检查一部分数据，仍会存在过期数据残留的问题。
- 惰性删除策略只在数据再次被访问时才会实际删除。如果客户端从主库上读取留存的过期数据，主库会触发删除操作，此时，客户端并不会读到过期数据。但是，从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除。那么，从库会给客户端返回过期数据吗？这就和你使用的Redis版本有关了。如果你使用的是Redis 3.2之前的版本，那么，从库在服务读请求时，并不会判断数据是否过期，而是会返回过期数据。在3.2版本后，Redis做了改进，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值，这就避免了客户端读到过期数据。所以，**在应用主从集群时，尽量使用 Redis 3.2 及以上版本**。

那只要使用了Redis 3.2 后的版本，就不会读到过期数据了吗？其实还是会的。原因跟 Redis 用于设置过期时间的命令有关系，有些命令给数据设置的过期时间在从库上可能会被延后，导致应该过期的数据又在从库上被读取到了，我来给你具体解释下。

设置数据过期时间的命令一共有4个，我们可以把它们分成两类：

- EXPIRE 和 PEXPIRE：它们给数据设置的是**从命令执行时开始计算的存活时间**；
- EXPIREAT 和 PEXPIREAT：**它们会直接把数据的过期时间设置为具体的一个时间点**。

这 4 个命令的参数和含义如下表所示：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230419110905.png" alt="$uploadName" style="zoom:75%;" /></center>

示例：

- `EXPIRE testkey 60`：把 testkey 的过期时间设置为 60s 后
- `EXPIREAT testkey 1603501200`：让testkey在2020年10月24日上午9点过期，命令中的1603501200就是以秒数时间戳表示的10月24日上午9点。

由于网络延迟，使用 EXPIRE 可能会让主从库的过期时间点不一样。因此建议：<font color=blue>在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据</font>。另外注意，EXPIREAT/PEXPIREAT 设置的是时间点，所以**主从节点上的时钟要保持一致**，具体的做法是，让主从节点和相同的 NTP 服务器(时间服务器)进行时钟同步。

### 1.3 不合理配置项导致的服务挂掉

这里涉及到的配置项有两个，分别是 **protected-mode 和 cluster-node-timeout**。

#### 1）protected-mode 配置项

这个配置项的作用是限定哨兵实例能否被其他服务器访问：

- yes：哨兵实例只能在部署的服务器本地进行访问
- no：其他服务器也可以访问这个哨兵实例

正因为这样，如果protected-mode被设置为yes，而其余哨兵实例部署在其它服务器，那么，这些哨兵实例间就无法通信。当主库故障时，哨兵无法判断主库下线，也无法进行主从切换，最终Redis服务不可用。

所以，**我们在应用主从集群时，要注意将 protected-mode 配置项设置为no，并且将bind配置项设置为其它哨兵实例的IP地址**。这样一来，只有在bind中设置了IP地址的哨兵，才可以访问当前实例，既保证了实例间能够通信进行主从切换，也保证了哨兵的安全性。

我们来看一个简单的小例子。如果设置了下面的配置项，那么，部署在192.168.10.3/4/5这三台服务器上的哨兵实例就可以相互通信，执行主从切换：

```plain
protected-mode no
bind 192.168.10.3 192.168.10.4 192.168.10.5
```

#### 2）cluster-node-timeout 配置项

**这个配置项设置了Redis Cluster中实例响应心跳消息的超时时间**。

当我们在Redis Cluster集群中为每个实例配置了“一主一从”模式时，如果主实例发生故障，从实例会切换为主实例，受网络延迟和切换操作执行的影响，切换时间可能较长，就会导致实例的心跳超时（超出cluster-node-timeout）。实例超时后，就会被Redis Cluster判断为异常。而Redis Cluster正常运行的条件就是，有半数以上的实例都能正常运行。

所以，如果执行主从切换的实例超过半数，而主从切换时间又过长的话，就可能有半数以上的实例心跳超时，从而可能导致整个集群挂掉。所以，<font color=blue>我建议你将cluster-node-timeout调大些（例如10到20秒）</font>。

### 1.4 小结

这一节主要讲了 Redis 做主从同步时可能出现的 3 个坑：主从数据不一致、读取到过期数据和不合理配置项导致服务挂掉。总结如下：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230419111416.png" alt="$uploadName" style="zoom:75%;" /></center>

最后，关于主从库数据不一致的问题，我还想再给你提一个小建议：Redis中的slave-serve-stale-data配置项设置了从库能否处理数据读写命令，你可以把它设置为no。这样一来，从库只能服务INFO、SLAVEOF命令，这就可以避免在从库中读到不一致的数据了。

不过，你要注意下这个配置项和slave-read-only的区别，slave-read-only是设置从库能否处理写命令，slave-read-only设置为yes时，从库只能处理读请求，无法处理写请求，你可不要搞混了。

> [这篇博文](https://www.rstk.cn/news/73044.html)讲同步讲的不错，都串起来了。
