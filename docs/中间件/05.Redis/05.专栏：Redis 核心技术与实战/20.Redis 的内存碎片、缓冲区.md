---
title: Redis 的内存碎片、缓冲区
date: 2023-04-09 17:15:43
permalink: /pages/6135bf/
categories:
  - 中间件
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [20 删除数据后，为什么内存占用率还是很高？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)
> + [21 缓冲区：一个可能引发“惨案”的地方 | 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

## 1. Redis 的内存碎片问题

使用 Redis 时经常会遇到这样一个问题：明明做了数据删除，数据量已经不大了，为什么使用`top`命令查看时，还会发现Redis占用了很多内存呢？实际上，这是因为，**当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统**。所以，操作系统仍然会记录着给Redis分配了大量内存。

但是，这往往会伴随一个潜在的风险点：**Redis 释放的内存空间可能并不是连续的**，那么，这些不连续的内存空间很有可能处于一种闲置的状态。这就会导致一个问题：虽然有空闲空间，Redis却无法用来保存数据，不仅会减少Redis能够实际保存的数据量，还会降低Redis运行机器的成本回报率。

这一节将讨论一下 Redis 的内存空间存储效率问题，探索一下，为什么数据已经删除了，但内存却闲置着没有用，以及相应的解决方案。

### 1.1 什么是内存碎片？

通常情况下，**内存空间闲置，往往是因为操作系统发生了较为严重的内存碎片，导致无法继续分配一块连续空间**。

内存碎片：内存中还有 5KB 的空余，但都是零散在不同地方，无法满足“申请一块连续 2KB 空间”的要求。

类似于3个人想买连着的火车票，但此时车上只有不连续的三个空座位，因此就换趟车了。

### 1.2 内存碎片是如何形成的？

其实，内存碎片的形成有内因和外因两个层面的原因。简单来说，<u>内因是操作系统的内存分配机制，外因是 Redis 的负载特征</u>。

#### 1.2.1 内因：内存分配器的分配策略

内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，**内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配**。

Redis可以使用libc、jemalloc、tcmalloc多种内存分配器来分配内存，<u>默认使用jemalloc</u>。接下来，我就以jemalloc为例，来具体解释一下。其他分配器也存在类似的问题。

jemalloc的分配策略之一，是按照一系列固定的大小划分内存空间，例如8字节、16字节、32字节、48字节，…, 2KB、4KB、8KB等。当程序申请的内存最接近某个固定值时，jemalloc会给它分配相应大小的空间。

这样的分配方式本身是为了减少分配次数。例如，Redis申请一个20字节的空间保存数据，jemalloc就会分配32字节，此时，如果应用还要写入10字节的数据，Redis就不用再向操作系统申请空间了，因为刚才分配的32字节已经够用了，这就避免了一次分配操作。

但是，<u>如果 Redis 每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险</u>，而这正好来源于 Redis 的外因了。

#### 1.2.2 外因：键值对大小不一样和删改操作

**第一个外因**：

Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。但内存分配器只能按固定大小分配内存，所以，分配的内存空间一般都会比申请的空间大一些，不会完全一致，这本身就会造成一定的碎片，降低内存空间存储效率。

**第二个外因**：

第二个外因是，这些键值对会被修改和删除，这会导致空间的扩容和释放。具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。

但这样频繁操作后，会形成很多碎片空间，它们不是连续的，导致难以被利用。如下图：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230409200353.png" alt="20230409200353" style="zoom:75%;" /></center>

---

好了，到这里，我们就知道了造成内存碎片的内外因素，其中，内存分配器策略是内因，而Redis的负载属于外因，包括了大小不一的键值对和键值对修改删除带来的内存空间变化。

大量内存碎片的存在，会造成 Redis 的内存实际利用率变低，接下来，我们就要来解决这个问题了。不过，在解决问题前，我们要先判断 Redis 运行过程中是否存在内存碎片。

### 1.3 如何判断是否有内存碎片？

为了让用户能监控到实时的内存使用情况，Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息，命令如下：

```plain
INFO memory
# Memory
used_memory:1073741736
used_memory_human:1024.00M
used_memory_rss:1997159792
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86
```

这里有一个 mem\_fragmentation\_ratio 的指标，它表示的就是 Redis 当前的内存碎片率。那么，这个碎片率是怎么计算的呢？其实，就是上面的命令中的两个指标used\_memory\_rss和used\_memory相除的结果：

```plain
mem_fragmentation_ratio = used_memory_rss/ used_memory
```

+ used\_memory\_rss 是操作系统实际分配给Redis的物理内存空间，里面就包含了碎片；
+ used\_memory 是 Redis 为了保存数据实际申请使用的空间。

这个指标如何使用呢？这里有一些经验阈值：

+ **mem\_fragmentation\_ratio 大于 1 但小于 1.5**。这种情况是合理的。这是因为，刚才我介绍的那些因素是难以避免的。毕竟，内因的内存分配器是一定要使用的，分配策略都是通用的，不会轻易修改；而外因由Redis负载决定，也无法限制。所以，存在内存碎片也是正常的。
+ **mem\_fragmentation\_ratio 大于 1.5** 。这表明内存碎片率已经超过了50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。

### 1.4 如何清理内存碎片？

#### 1.4.1 重启 Redis 的方法

当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是**重启Redis实例**。当然，这并不是一个“优雅”的方法，毕竟，重启 Redis 会带来两个后果：

+ 如果 Redis 中的数据没有持久化，那么，数据就会丢失；
+ 即使 Redis 数据持久化了，我们还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。

#### 1.4.2 内存碎片自动清理的方法

所以，还有什么其他好办法吗？幸运的是，从 4.0-RC3 版本以后，Redis 自身提供了一种内存碎片自动清理的方法，我们先来看这个方法的基本机制：“**搬家让位，合并空间**”，用一张图来解释就是：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230409200754.png" alt="20230409200754" style="zoom:75%;" /></center>

以刚刚的高铁的例子来看，就是三个人买了不在一起的车票，上车之后和别人调换作为，坐在了一起。

当然，如果数据拷贝后，并没有形成连续的内存空间，这就不能算是清理了。

不过需要注意：**碎片清理是有代价的**，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销，会阻塞 Redis 的线程。

有什么办法可以尽量缓解这个问题吗？这就要提到 Redis 专门为自动内存碎片清理机制设置的参数了。我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的CPU比例，从而<u>减少碎片清理对 Redis 本身请求处理的性能影响</u>。

#### 1.4.3 内存碎片自动清理的相关参数

首先，Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes，命令如下：

```plain
config set activedefrag yes
```

这个命令只是启用了自动清理功能，但是，具体什么时候清理，会受到下面这两个参数的控制。这两个参数分别设置了触发内存清理的一个条件，如果同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理：

+ **active-defrag-ignore-bytes 100mb**：表示内存碎片的字节数达到100MB时，开始清理；
+ **active-defrag-threshold-lower 10**：表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。

为了尽可能减少碎片清理对 Redis 正常请求处理的影响，自动内存碎片清理功能在执行时，还会<u>监控清理操作占用的 CPU 时间</u>，而且还设置了两个参数，分别用于控制清理操作占用的CPU时间比例的上、下限，既保证清理工作能正常进行，又避免了降低 Redis 性能。这两个参数具体如下：

+ **active-defrag-cycle-min 25**： 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；
+ **active-defrag-cycle-max 75**：表示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。

自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对 Redis 内存使用效率的影响，还考虑了清理机制本身的 CPU 时间占比、对 Redis 性能的影响。而且，清理机制还提供了 4 个参数，让我们可以根据实际应用中的数据量需求和性能要求灵活使用，建议你在实践中好好地把这个机制用起来。

### 1.5 小结

这一大节主要了解了 Redis 的内存空间效率问题，这里面的一个关键技术点就是要识别和处理内存碎片：

+ info memory 命令是一个**好工具**，可以帮助你查看碎片率的情况；
+ 碎片率阈值是一个**好经验**，可以帮忙你有效地判断是否要进行碎片清理了；
+ 内存碎片自动清理是一个**好方法**，可以避免因为碎片导致 Redis 的内存实际利用率降低，提升成本收益率。

内存碎片并不可怕，我们要做的就是了解它，重视它，并借用高效的方法解决它。

最后，我再给你提供一个小贴士：**内存碎片自动清理涉及内存拷贝，这对Redis而言，是个潜在的风险**。如果你在实践过程中遇到Redis性能变慢，记得通过日志看下是否正在进行碎片清理。如果Redis的确正在清理碎片，那么，我建议你调小active-defrag-cycle-max的值，以减轻对正常请求处理的影响。
