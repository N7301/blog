<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 的消息队列方案 | Nrich&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/blog/img/bitbug_favicon.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.5e70c998.css" as="style"><link rel="preload" href="/blog/assets/js/app.73302609.js" as="script"><link rel="preload" href="/blog/assets/js/2.c02cd514.js" as="script"><link rel="preload" href="/blog/assets/js/27.ac60ace0.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ccc2fc76.js"><link rel="prefetch" href="/blog/assets/js/11.15e920f7.js"><link rel="prefetch" href="/blog/assets/js/12.d6b747fb.js"><link rel="prefetch" href="/blog/assets/js/13.ee8d04f3.js"><link rel="prefetch" href="/blog/assets/js/14.b7513ca5.js"><link rel="prefetch" href="/blog/assets/js/15.f2e8ff40.js"><link rel="prefetch" href="/blog/assets/js/16.347a6e24.js"><link rel="prefetch" href="/blog/assets/js/17.6c1e9625.js"><link rel="prefetch" href="/blog/assets/js/18.7602b54c.js"><link rel="prefetch" href="/blog/assets/js/19.8f4fcc4b.js"><link rel="prefetch" href="/blog/assets/js/20.09885064.js"><link rel="prefetch" href="/blog/assets/js/21.b525f277.js"><link rel="prefetch" href="/blog/assets/js/22.b9ed6df2.js"><link rel="prefetch" href="/blog/assets/js/23.523e5d22.js"><link rel="prefetch" href="/blog/assets/js/24.d04239a4.js"><link rel="prefetch" href="/blog/assets/js/25.237a6c47.js"><link rel="prefetch" href="/blog/assets/js/26.6bd9bfe4.js"><link rel="prefetch" href="/blog/assets/js/28.ee14024f.js"><link rel="prefetch" href="/blog/assets/js/29.0caa2b3a.js"><link rel="prefetch" href="/blog/assets/js/3.620a1f91.js"><link rel="prefetch" href="/blog/assets/js/30.e6e7d6f8.js"><link rel="prefetch" href="/blog/assets/js/31.6ec6039c.js"><link rel="prefetch" href="/blog/assets/js/32.37f8dd2f.js"><link rel="prefetch" href="/blog/assets/js/33.7e29804a.js"><link rel="prefetch" href="/blog/assets/js/34.8eeb5b9d.js"><link rel="prefetch" href="/blog/assets/js/35.72aa34f7.js"><link rel="prefetch" href="/blog/assets/js/36.9de84a28.js"><link rel="prefetch" href="/blog/assets/js/37.64e3dd13.js"><link rel="prefetch" href="/blog/assets/js/38.99ad5507.js"><link rel="prefetch" href="/blog/assets/js/39.8cda7b61.js"><link rel="prefetch" href="/blog/assets/js/4.0df20a49.js"><link rel="prefetch" href="/blog/assets/js/40.ed6949c0.js"><link rel="prefetch" href="/blog/assets/js/41.bf343b6b.js"><link rel="prefetch" href="/blog/assets/js/42.cbbfd0d9.js"><link rel="prefetch" href="/blog/assets/js/43.39209b19.js"><link rel="prefetch" href="/blog/assets/js/44.7eec5b18.js"><link rel="prefetch" href="/blog/assets/js/45.b088db4c.js"><link rel="prefetch" href="/blog/assets/js/46.bfc9e511.js"><link rel="prefetch" href="/blog/assets/js/47.d0b2aa80.js"><link rel="prefetch" href="/blog/assets/js/48.49b8f1b4.js"><link rel="prefetch" href="/blog/assets/js/49.72f6d0a1.js"><link rel="prefetch" href="/blog/assets/js/5.94069b5e.js"><link rel="prefetch" href="/blog/assets/js/50.dcbe6aa5.js"><link rel="prefetch" href="/blog/assets/js/51.cca2da80.js"><link rel="prefetch" href="/blog/assets/js/52.063ad237.js"><link rel="prefetch" href="/blog/assets/js/53.65573113.js"><link rel="prefetch" href="/blog/assets/js/54.e3b86f9a.js"><link rel="prefetch" href="/blog/assets/js/55.e23d17b7.js"><link rel="prefetch" href="/blog/assets/js/56.c47badfb.js"><link rel="prefetch" href="/blog/assets/js/57.8c7d3e16.js"><link rel="prefetch" href="/blog/assets/js/58.52fb51c8.js"><link rel="prefetch" href="/blog/assets/js/59.8ee7423a.js"><link rel="prefetch" href="/blog/assets/js/6.90726693.js"><link rel="prefetch" href="/blog/assets/js/60.7c6906fd.js"><link rel="prefetch" href="/blog/assets/js/61.898384c1.js"><link rel="prefetch" href="/blog/assets/js/62.6bf3cdda.js"><link rel="prefetch" href="/blog/assets/js/63.fed7f6ff.js"><link rel="prefetch" href="/blog/assets/js/64.62128c79.js"><link rel="prefetch" href="/blog/assets/js/65.dd8213b3.js"><link rel="prefetch" href="/blog/assets/js/66.579f1a82.js"><link rel="prefetch" href="/blog/assets/js/67.fa647f5d.js"><link rel="prefetch" href="/blog/assets/js/68.d535a10d.js"><link rel="prefetch" href="/blog/assets/js/69.4d7e0d52.js"><link rel="prefetch" href="/blog/assets/js/7.ba20b3c7.js"><link rel="prefetch" href="/blog/assets/js/70.4b6cd449.js"><link rel="prefetch" href="/blog/assets/js/71.be36a223.js"><link rel="prefetch" href="/blog/assets/js/72.f57cde07.js"><link rel="prefetch" href="/blog/assets/js/73.a4087adf.js"><link rel="prefetch" href="/blog/assets/js/74.8f60ef05.js"><link rel="prefetch" href="/blog/assets/js/75.fdc945ab.js"><link rel="prefetch" href="/blog/assets/js/76.d1f1faa5.js"><link rel="prefetch" href="/blog/assets/js/77.687a6763.js"><link rel="prefetch" href="/blog/assets/js/78.97f56bb1.js"><link rel="prefetch" href="/blog/assets/js/79.35c1de5f.js"><link rel="prefetch" href="/blog/assets/js/8.2abb0131.js"><link rel="prefetch" href="/blog/assets/js/80.fbe50656.js"><link rel="prefetch" href="/blog/assets/js/81.102e33bc.js"><link rel="prefetch" href="/blog/assets/js/82.4f73285b.js"><link rel="prefetch" href="/blog/assets/js/9.ece9abdb.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5e70c998.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/mylogo.jpeg" alt="Nrich's blog" class="logo"> <span class="site-name can-hide">Nrich's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><!----> <span class="title" style="display:;">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">Golang</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AI" class="dropdown-title"><!----> <span class="title" style="display:;">AI</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/deep-learning/" class="nav-link">深度学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/blog/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/datastructure/" class="nav-link">DataStructure</a></li><li class="dropdown-item"><!----> <a href="/blog/cloudnative/" class="nav-link">CloudNative</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><!----> <span class="title" style="display:;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/blog/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><!----> <span class="title" style="display:;">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/route-hijack/" class="nav-link">路由劫持</a></li></ul></div></div> <a href="https://github.com/n7301/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/head.jpg"> <div class="blogger-info"><h3>Nrich</h3> <span>小聪明</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><!----> <span class="title" style="display:;">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">Golang</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AI" class="dropdown-title"><!----> <span class="title" style="display:;">AI</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/deep-learning/" class="nav-link">深度学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/blog/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/datastructure/" class="nav-link">DataStructure</a></li><li class="dropdown-item"><!----> <a href="/blog/cloudnative/" class="nav-link">CloudNative</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><!----> <span class="title" style="display:;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/blog/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><!----> <span class="title" style="display:;">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/route-hijack/" class="nav-link">路由劫持</a></li></ul></div></div> <a href="https://github.com/n7301/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>专栏：Redis 核心技术与实战</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/271391/" class="sidebar-link">基础架构、数据结构与 IO 模型</a></li><li><a href="/blog/pages/d1a6d3/" class="sidebar-link">持久化机制：AOF日志和RDB快照</a></li><li><a href="/blog/pages/348567/" class="sidebar-link">主从复制与哨兵机制</a></li><li><a href="/blog/pages/71b166/" class="sidebar-link">切片集群</a></li><li><a href="/blog/pages/2029a8/" class="sidebar-link">Redis 中的数据结构</a></li><li><a href="/blog/pages/a3ed18/" class="sidebar-link">时间序列数据的保存</a></li><li><a href="/blog/pages/5d636a/" aria-current="page" class="active sidebar-link">Redis 的消息队列方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/5d636a/#_1-消息队列的考验-redis有哪些解决方案" class="sidebar-link">1. 消息队列的考验：Redis有哪些解决方案？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/5d636a/#_1-1-mq-的消息存取需求" class="sidebar-link">1.1 MQ 的消息存取需求</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#需求一-消息保序" class="sidebar-link">需求一：消息保序</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#需求二-重复消息处理-幂等要求" class="sidebar-link">需求二：重复消息处理（幂等要求）</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#需求三-消息可靠性保证" class="sidebar-link">需求三：消息可靠性保证</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/5d636a/#_1-2-基于-list-的-mq-解决方案" class="sidebar-link">1.2 基于 List 的 MQ 解决方案</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_1-2-1-解决消息保序问题" class="sidebar-link">1.2.1 解决消息保序问题</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_1-2-2-幂等性要求-处理重复消息" class="sidebar-link">1.2.2 幂等性要求（处理重复消息）</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_1-2-3-消息可靠性保证" class="sidebar-link">1.2.3 消息可靠性保证</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/5d636a/#_1-3-基于-streams-的消息队列解决方案" class="sidebar-link">1.3 基于 Streams 的消息队列解决方案</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_1-xadd-命令" class="sidebar-link">1）XADD 命令</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_2-xread-命令" class="sidebar-link">2）XREAD 命令</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_3-xgroup-与-xreadgroup" class="sidebar-link">3）XGROUP 与 XREADGROUP</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/5d636a/#_4-xpending-和-xack" class="sidebar-link">4）XPENDING 和 XACK</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/5d636a/#_1-4-小结" class="sidebar-link">1.4 小结</a></li></ul></li></ul></li><li><a href="/blog/pages/ca62e3/" class="sidebar-link">异步机制、CPU 架构对性能的影响</a></li><li><a href="/blog/pages/f111bf/" class="sidebar-link">如何应对变慢的 Redis</a></li><li><a href="/blog/pages/6135bf/" class="sidebar-link">Redis 的内存碎片、缓冲区</a></li><li><a href="/blog/pages/d403e5/" class="sidebar-link">Redis 用作缓存</a></li><li><a href="/blog/pages/cbe81b/" class="sidebar-link">Redis 用作缓存之缓存异常</a></li><li><a href="/blog/pages/ea52c5/" class="sidebar-link">Redis 用作缓存之缓存污染</a></li><li><a href="/blog/pages/8f7740/" class="sidebar-link">Pika：基于SSD实现大容量Redis</a></li><li><a href="/blog/pages/5a1b01/" class="sidebar-link">无锁的原子操作和分布式锁</a></li><li><a href="/blog/pages/932816/" class="sidebar-link">Redis 的事务机制</a></li><li><a href="/blog/pages/4140fe/" class="sidebar-link">Redis 主从同步的坑</a></li><li><a href="/blog/pages/b6efd0/" class="sidebar-link">秒杀场景下的应用</a></li><li><a href="/blog/pages/d3d97d/" class="sidebar-link">集群的数据倾斜和通信开销问题</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/categories/?category=%E4%B8%AD%E9%97%B4%E4%BB%B6" title="分类" data-v-06225672>中间件</a></li><li data-v-06225672><a href="/blog/categories/?category=Redis" title="分类" data-v-06225672>Redis</a></li><li data-v-06225672><a href="/blog/categories/?category=%E4%B8%93%E6%A0%8F%EF%BC%9ARedis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98" title="分类" data-v-06225672>专栏：Redis 核心技术与实战</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/Nrich-sunny" target="_blank" title="作者" class="beLink" data-v-06225672>Nrich</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-04-06</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Redis 的消息队列方案<!----></h1>  <div class="theme-vdoing-content content__default"><blockquote><p>参考：</p> <ul><li><a href="https://time.geekbang.org/column/intro/100056701?tab=catalog" target="_blank" rel="noopener noreferrer">15 消息队列的考验：Redis 有哪些解决方案？| 极客时间<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote> <h2 id="_1-消息队列的考验-redis有哪些解决方案"><a href="#_1-消息队列的考验-redis有哪些解决方案" class="header-anchor">#</a> 1. 消息队列的考验：Redis有哪些解决方案？</h2> <p>消息队列是分布式系统的基础软件，要能支持组件通信消息的快速读写。Redis 本身支持数据的高速访问，因此很多人关心一个问题：Redis 适合做 MQ 吗？</p> <p>这个问题的背后，隐含着两方面的核心问题：</p> <ul><li>消息队列的消息存取需求是什么？</li> <li>Redis 如何实现消息队列的需求？</li></ul> <p>理解了 MQ 的特征和 Redis 提供的 MQ 方案，才能根据实际需求来选择出适合的 Redis 消息队列方案。</p> <h3 id="_1-1-mq-的消息存取需求"><a href="#_1-1-mq-的消息存取需求" class="header-anchor">#</a> 1.1 MQ 的消息存取需求</h3> <p>先介绍一下<strong>消息队列存取消息的过程</strong>。在分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。</p> <p>一个通用的 MQ 的架构模型为：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406112919.png" alt="$uploadName" style="zoom:75%;"></center> <p>消息队列中发送消息的组件称为<mark>生产者</mark>，接收消息的组件称为<mark>消费者</mark>。</p> <p>在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是<font color="blue">消息队列作为分布式组件通信的一大优势</font>。</p> <p>MQ 在存取消息时，必须要满足三个需求：</p> <ol><li>消息保序</li> <li>处理重复的消息（幂等要求）</li> <li>保证消息可靠性</li></ol> <h4 id="需求一-消息保序"><a href="#需求一-消息保序" class="header-anchor">#</a> 需求一：消息保序</h4> <p>虽然消费者是<strong>异步处理消息</strong>，但是，<strong>消费者仍然需要按照生产者发送消息的顺序来处理消息</strong>，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。</p> <p>我们来看一个更新商品库存的场景：假设生产者负责接收库存更新请求，消费者负责实际更新库存，现有库存量是10。生产者先后发送了消息1和消息2，消息1要把商品X的库存记录更新为5，消息2是把商品X库存更新为3。如果消息1和2在消息队列中无法保序，出现消息2早于消息1被处理的情况，那么，很显然，库存更新就出错了。这是业务应用无法接受的。</p> <h4 id="需求二-重复消息处理-幂等要求"><a href="#需求二-重复消息处理-幂等要求" class="header-anchor">#</a> 需求二：重复消息处理（幂等要求）</h4> <p>消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。</p> <p>比如可能出现重复扣款的问题。</p> <h4 id="需求三-消息可靠性保证"><a href="#需求三-消息可靠性保证" class="header-anchor">#</a> 需求三：消息可靠性保证</h4> <p>消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p> <p>Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。下面来看这两种方案。</p> <h3 id="_1-2-基于-list-的-mq-解决方案"><a href="#_1-2-基于-list-的-mq-解决方案" class="header-anchor">#</a> 1.2 基于 List 的 MQ 解决方案</h3> <h4 id="_1-2-1-解决消息保序问题"><a href="#_1-2-1-解决消息保序问题" class="header-anchor">#</a> 1.2.1 解决消息保序问题</h4> <p>List 本身就是按先进先出的顺序对数据进行存取的，所以如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了：</p> <ul><li>生产者使用 <mark>LPUSH 命令</mark>把消息写入 List</li> <li>消费者使用 <mark>RPOP 命令</mark>读取消息</li></ul> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406162435.png" alt="$uploadName" style="zoom:75%;"></center> <p>不过这样的话 List 不会主动告知消费者有新消息的写入，这样就需要消费者一直调用 RPOP 来监听消息（比如使用一个while(1)循环），这会带来不必要的性能损失。</p> <p>为了解决这个问题，Redis 提供了 <mark>BRPOP 命令</mark>：<strong>阻塞式读取</strong>，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。这种方式相比消费者不停调用 RPOP 而言，更加<u>节省 CPU 开销</u>。</p> <h4 id="_1-2-2-幂等性要求-处理重复消息"><a href="#_1-2-2-幂等性要求-处理重复消息" class="header-anchor">#</a> 1.2.2 幂等性要求（处理重复消息）</h4> <p>解决消息重复问题，其实有一个要求：消费者程序本身能对重复消息进行判断：</p> <ul><li>一方面，消息队列要能给每一个消息提供全局唯一的 ID 号；</li> <li>另一方面，消费者程序要把已经处理过的消息的 ID 号记录下来。</li></ul> <p><mark>幂等性</mark>就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。</p> <p>因为 List 本身不会为消息生成 ID 号，因此<font color="blue">需要生产者在发送消息时附带上全局唯一 ID</font>。例如，我们执行以下命令，就把一条全局 ID 为 101030001、库存量为 5 的消息插入了消息队列：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>LPUSH mq &quot;101030001:stock:5&quot;
(integer) 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_1-2-3-消息可靠性保证"><a href="#_1-2-3-消息可靠性保证" class="header-anchor">#</a> 1.2.3 消息可靠性保证</h4> <p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p> <p>为了留存消息，List 类型提供了 <mark>BRPOPLPUSH 命令</mark>，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。下图是使用 BRPOPLPUSH 命令留存消息，以及消费者再次读取消息的过程：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406163205.png" alt="$uploadName" style="zoom:75%;"></center> <p>好了，到这里你可以看到，基于 List 类型，我们可以满足分布式组件对消息队列的三大需求。但是，在用 List 做消息队列时，我们还可能遇到过一个问题：<strong>生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力</strong>。这个时候，我们希望启动多个消费者程序组成一个<strong>消费组</strong>，一起分担处理 List 中的消息。但是，List 类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢？这就要说到 Redis 从 5.0 版本开始提供的 Streams 数据类型了。</p> <p>和 List 相比，Streams 同样能够满足消息队列的三大需求。而且，它还支持消费组形式的消息读取。接下来，我们就来了解下 Streams 的使用方法。</p> <h3 id="_1-3-基于-streams-的消息队列解决方案"><a href="#_1-3-基于-streams-的消息队列解决方案" class="header-anchor">#</a> 1.3 基于 Streams 的消息队列解决方案</h3> <p><mark>Streams</mark> 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令：</p> <ul><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li> <li>XREAD：用于读取消息，可以按 ID 读取数据；</li> <li>XREADGROUP：按消费组形式读取消息；</li> <li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li></ul> <h4 id="_1-xadd-命令"><a href="#_1-xadd-命令" class="header-anchor">#</a> 1）XADD 命令</h4> <p><strong>XADD 命令可以往消息队列中插入新消息，消息的格式是键-值对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID</strong>。</p> <p>比如说，我们执行下面的命令，就可以往名称为 mqstream 的消息队列中插入一条消息，消息的键是repo，值是5。其中，消息队列名称后面的 <code>*</code>，表示让Redis为插入的数据自动生成一个全局唯一的ID，例如“1599203861727-0”。当然，我们也可以不用 <code>*</code>，直接在消息队列名称后自行设定一个ID号，只要保证这个ID号是全局唯一的就行。不过，相比自行设定ID号，使用 <code>*</code> 会更加方便高效。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XADD mqstream * repo 5
&quot;1599203861727-0&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，消息的全局唯一ID由两部分组成，第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从0开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第1条消息。</p> <h4 id="_2-xread-命令"><a href="#_2-xread-命令" class="header-anchor">#</a> 2）XREAD 命令</h4> <p><strong>当消费者需要读取消息时，可以直接使用XREAD命令从消息队列中读取</strong>。XREAD 在读取消息时，可以指定一个消息 ID，并<u>从这个消息 ID 的下一条消息开始进行读取</u>。</p> <p>例如，我们可以执行下面的命令，从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息（示例中一共 3 条）：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0
1) 1) &quot;mqstream&quot;
   2) 1) 1) &quot;1599274912765-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;3&quot;
      2) 1) &quot;1599274925823-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;2&quot;
      3) 1) &quot;1599274927910-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;1&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>另外，消费者也可以在调用 XRAED 时设定 <strong>block 配置项</strong>，实现类似于 BRPOP 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，XREAD 就会阻塞，阻塞的时长可以在 block 配置项进行设置。</p> <p>举个例子，我们来看一下下面的命令，其中，命令最后的“$”符号表示读取最新的消息，同时，我们设置了block 10000的配置项，10000的单位是毫秒，表明XREAD在读取最新消息时，如果没有消息到来，XREAD将阻塞10000毫秒（即10秒），然后再返回。下面命令中的XREAD执行后，消息队列mqstream中一直没有消息，所以，XREAD在10秒后返回空值（nil）：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XREAD block 10000 streams mqstream $
(nil)
(10.00s)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>刚刚讲到的这些操作是 List 也支持的，接下来，我们再来学习下 Streams 特有的功能。</p> <h4 id="_3-xgroup-与-xreadgroup"><a href="#_3-xgroup-与-xreadgroup" class="header-anchor">#</a> 3）XGROUP 与 XREADGROUP</h4> <p>Streams 本身<strong>可以使用 XGROUP 创建消费组，创建消费组之后，Streams 可以使用 XREADGROUP 命令让消费组内的消费者读取消息</strong>。</p> <p>例如，我们执行下面的命令，创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XGROUP create mqstream group1 0
OK
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后，我们再执行一段命令，让group1消费组里的消费者consumer1从mqstream中读取所有消息，其中，命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。因为在consumer1读取消息前，group1中没有其他消费者读取过消息，所以，consumer1就得到mqstream消息队列中的所有消息了（一共4条）：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XREADGROUP group group1 consumer1 streams mqstream &gt;
1) 1) &quot;mqstream&quot;
   2) 1) 1) &quot;1599203861727-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;5&quot;
      2) 1) &quot;1599274912765-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;3&quot;
      3) 1) &quot;1599274925823-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;2&quot;
      4) 1) &quot;1599274927910-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;1&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>需要注意的是，<font color="blue">消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了</font>。比如说，我们执行完刚才的XREADGROUP命令后，再执行下面的命令，让group1内的consumer2读取消息时，consumer2读到的就是空值，因为消息已经被consumer1读取完了，如下所示：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XREADGROUP group group1 consumer2  streams mqstream 0
1) 1) &quot;mqstream&quot;
   2) (empty list or set)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><font color="blue">使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</font>。例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;
1) 1) &quot;mqstream&quot;
   2) 1) 1) &quot;1599203861727-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;5&quot;

XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;
1) 1) &quot;mqstream&quot;
   2) 1) 1) &quot;1599274912765-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;3&quot;

XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;
1) 1) &quot;mqstream&quot;
   2) 1) 1) &quot;1599274925823-0&quot;
         2) 1) &quot;repo&quot;
            2) &quot;2&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="_4-xpending-和-xack"><a href="#_4-xpending-和-xack" class="header-anchor">#</a> 4）XPENDING 和 XACK</h4> <p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用<mark>内部队列</mark>（也称为 <mark></mark>PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 <mark>XACK 命令</mark>通知Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 <mark>XPENDING 命令</mark>查看已读取、但尚未确认处理完成的消息。</p> <p>例如，我们来查看一下group2中各个消费者已读取、但尚未确认的消息个数。其中，XPENDING返回结果的第二、三行分别表示group2中所有消费者读取的消息最小ID和最大ID：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XPENDING mqstream group2
1) (integer) 3
2) &quot;1599203861727-0&quot;
3) &quot;1599274925823-0&quot;
4) 1) 1) &quot;consumer1&quot;
      2) &quot;1&quot;
   2) 1) &quot;consumer2&quot;
      2) &quot;1&quot;
   3) 1) &quot;consumer3&quot;
      2) &quot;1&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果我们还需要进一步查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>XPENDING mqstream group2 - + 10 consumer2
1) 1) &quot;1599274912765-0&quot;
   2) &quot;consumer2&quot;
   3) (integer) 513336
   4) (integer) 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，consumer2 已读取的消息的 ID 是 1599274912765-0。</p> <p>一旦消息 1599274912765-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code> XACK mqstream group2 1599274912765-0
(integer) 1
XPENDING mqstream group2 - + 10 consumer2
(empty list or set)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>现在，我们就知道了用 Streams 实现消息队列的方法，我还想再强调下，<strong>Streams 是 Redis 5.0 专门针对消息队列场景设计的数据类型</strong>，如果你的 Redis 是5.0及5.0以后的版本，就可以考虑把 Streams 用作消息队列了。</p> <h3 id="_1-4-小结"><a href="#_1-4-小结" class="header-anchor">#</a> 1.4 小结</h3> <p>我们学习了分布式系统组件使用消息队列时的三大需求：消息保序、重复消息处理和消息可靠性保证，这三大需求可以进一步转换为对消息队列的三大要求：消息数据有序存取，消息数据具有全局唯一编号，以及消息数据在消费完成后被删除。</p> <p>下图汇总了 List 和 Streams 实现消息队列的特点和区别：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406203015.png" alt="20230406203015" style="zoom:75%;"></center> <blockquote><p>其实，关于Redis是否适合做消息队列，业界一直是有争论的。很多人认为，要使用消息队列，就应该采用 Kafka、RabbitMQ 这些专门面向消息队列场景的软件，而 Redis 更加适合做缓存。</p> <p>根据这些年做Redis研发工作的经验，我的看法是：Redis是一个非常轻量级的键值数据库，部署一个Redis实例就是启动一个进程，部署Redis集群，也就是部署多个Redis实例。而Kafka、RabbitMQ部署时，涉及额外的组件，例如Kafka的运行就需要再部署ZooKeeper。<strong>相比Redis来说，Kafka和RabbitMQ一般被认为是重量级的消息队列</strong>。</p> <p>所以，关于是否用Redis做消息队列的问题，不能一概而论，我们需要考虑业务层面的数据体量，以及对性能、可靠性、可扩展性的需求。<strong>如果分布式系统中的组件消息通信量不大</strong>，那么，Redis只需要使用有限的内存空间就能满足消息存储的需求，而且，Redis的高性能特性能支持快速的消息读写，不失为消息队列的一个好的解决方案。</p></blockquote> <hr> <p><strong>本节问题：如果一个生产者发送给消息队列的消息，需要被多个消费者进行读取和处理（例如，一个消息是一条从业务系统采集的数据，既要被消费者1读取并进行实时计算，也要被消费者2读取并留存到分布式文件系统HDFS中，以便后续进行历史查询），你会使用Redis的什么数据类型来解决这个问题呢</strong>？</p> <p>可以使用Streams数据类型的消费组，同时消费生产者的数据，这是可以的。但是，需要注意，如果只是使用一个消费组的话，消费组内的多个消费者在消费消息时是互斥的，换句话说，在一个消费组内，一个消息只能被一个消费者消费。我们希望消息既要被消费者1读取，也要被消费者2读取，是一个多消费者的需求。所以，如果使用消费组模式，需要让消费者1和消费者2属于不同的消费组，这样它们就能同时消费了。</p> <p>另外，Redis基于字典和链表数据结构，实现了发布和订阅功能，这个功能可以实现一个消息被多个消费者消费使用，可以满足问题中的场景需求。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/n7301/blog/edit/master/docs/中间件/05.Redis/05.专栏：Redis 核心技术与实战/15.Redis 的消息队列方案.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/04/10, 14:17:28</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/a3ed18/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">时间序列数据的保存</div></a> <a href="/blog/pages/ca62e3/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">异步机制、CPU 架构对性能的影响</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/a3ed18/" class="prev">时间序列数据的保存</a></span> <span class="next"><a href="/blog/pages/ca62e3/">异步机制、CPU 架构对性能的影响</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/c0d84b/"><div>
            YAML、Pod、Job、CronJob、ConfigMap、Secret
            <!----></div></a> <span class="date">06-06</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/757154/"><div>
            Kubernetes 的安装与基本架构
            <!----></div></a> <span class="date">06-04</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/1cc8db/"><div>
            初识容器
            <!----></div></a> <span class="date">05-30</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/Nrich-sunny" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>Nrich | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/blog/assets/js/app.73302609.js" defer></script><script src="/blog/assets/js/2.c02cd514.js" defer></script><script src="/blog/assets/js/27.ac60ace0.js" defer></script>
  </body>
</html>
