---
title: 主从复制与哨兵机制
date: 2023-03-25 22:21:29
permalink: /pages/348567/
categories:
  - 中间件
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

# 主从复制与哨兵机制

> 参考：
>
> - [06 数据同步：主从库如何实现数据一致？| 极客时间(opens new window)](https://time.geekbang.org/column/intro/100056701?tab=catalog)
> - [07 哨兵机制：主库挂了，如何不间断服务？| 极客时间(opens new window)](https://time.geekbang.org/column/intro/100056701?tab=catalog)
> - [08 哨兵集群：哨兵挂了，主从库还能切换吗？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

我们使用 AOF 和 RDB，保证尽量少丢失数据，提升可靠性。但依然存在不可用问题。

假设我们的 Redis 只有一个实例，那么当这个实例宕机，那就无法继续提供服务了。我们总说 Redis 具有高可靠性，其实有两层含义：

- 一是数据尽量少丢失。
- 二是服务尽量少中断。

AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是**增加副本冗余量**，这样当一个实例出现故障后，其他实例可以继续提供服务。

**Redis 使用了主从复制的模式来做数据复制**，主从库之间采用的是“读写分离”的方式：

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230215130520.png" alt="20230215130520" style="zoom:67%;" /></center>

主从复制的模式就面临 [DDIA 数据复制](https://yubincloud.github.io/notebook/pages/DDIA/note/replication/) 中所讨论的一系列问题。下面我们对 Redis 在该模式上的实践进行讨论。

主从库同步是如何完成的呢？主库数据是一次性传给从库，还是分批同步？要是主从库间的网络断连了，数据还能保持一致吗？下面聊聊主从库同步的原理，以及应对网络断连风险的方案。

## 1. 数据同步：主从库如何实现数据一致？

这一大节主要讨论主从库同步的原理，以及应对网络断连风险的方案。

首先看一下主从库间的第一次同步是如何进行的，这也是 Redis 实例建立主从库模式后的规定动作。

###  1.1 主从库间如何进行第一次同步？

当我们启动多个 Redis 实例的时候，**它们相互之间就可以通过 <mark>replicaof</mark>（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系**，之后会按照三个阶段完成数据的第一次同步。

例如，现在有实例1（ip：172.16.19.3）和实例2（ip：172.16.19.5），我们在实例2上执行以下这个命令后，实例2就变成了实例1的从库，并从实例1上复制数据：

```sh
replicaof  172.16.19.3  6379
```

接下来，我们就要学习主从库间数据第一次同步的三个阶段了：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230215161912.png" alt="20230215161912"  />

<mark>第一阶段</mark>是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，**从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了**。

具体来说，从库给主库发送 **psync 命令**，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync命令包含了**主库的 runID**和**复制进度 offset** 两个参数：

- runID：是每个 Redis 实例启动时都会自动生成的一个随机 ID，**用来唯一标记这个实例**。当从库和主库第一次复制时，因为不知道主库的 runID，所以将runID设为“?”。
- offset：此时设为 -1，表示第一次复制。

主库收到 psync 命令后，会用 **FULLRESYNC 响应命令**带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。

这里有个地方需要注意，**FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库**。

在<mark>第二阶段</mark>，**主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载**。这个过程依赖于内存快照生成的 RDB 文件。

具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。

在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 <font color="blue">**replication buffer**</font>，记录 RDB 文件生成后收到的所有写操作。

最后，也就是<mark>第三阶段</mark>，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

### 1.2 主从级联模式分担全量复制时的主库压力

在主从同步时，全量复制的阶段需要主库完成<u>两个耗时的操作</u>：生成 RDB 和传输 RDB。

若从库数量很多且都需要进行全量复制，会让主库忙于 fork 子进程生成 RDB，导致主库响应请求速度变慢。同时传输 RDB 也需要占用主库的带宽。那么，有没有好的解决方法来分担主库压力呢？这就是<mark>“主-从-从”</mark>模式。

刚刚介绍的主从模式中，所有的从库都是从主库同步而来的，现在我们**可以通过“主-从-从”的模式将主库生成的 RDB 和传输 RDB 的压力以级联的方式分散到从库上**。

简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系：

```sh
replicaof  所选从库的IP 6379
```

这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力，如下图所示：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230226150822.png" alt="20230226150822" style="zoom:80%;" /></center>

以上就是“主-从-从”模式的同步。一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为<mark>基于长连接的命令传播</mark>，可以避免频繁建立连接的开销。

这个数据同步的过程存在一个风险点：**<u>网络断连或阻塞</u>**。如果网络断连，主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持一致了，客户端就可能从从库读到旧数据。接下来，我们就来聊聊网络断连后的解决办法.

### 1.3 主从库间网络断了怎么办？

在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。

从 Redis 2.8 开始，<u>网络断了之后</u>，主从库会采用**增量复制**的方式继续同步。也就是只会把网络断连期间主库收到的命令，同步给从库。

那么，<u>增量复制时，主从库之间具体是怎么保持同步的呢</u>？这里的奥妙就在于 <mark><font color="blue">**repl_backlog_buffer**</font></mark> 这个缓冲区。我们先来看下它是如何用于增量命令的同步的。

当主从库断连后，主库会把断连期间收到的写操作命令，写入 <font color="blue">**replication buffer**</font> ，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。<mark><font color="blue">**repl_backlog_buffer**</font></mark> **是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置**。

刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 **master_repl_offset**。主库接收的新写操作越多，这个值就会越大。同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 **slave_repl_offset** 也在不断增加。正常情况下，这两个偏移量基本相等。

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/image-20230325225327667.png" alt="image-20230325225327667" style="zoom: 25%;" /></center>

<u>主从库的连接恢复之后</u>，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。

就像刚刚示意图的中间部分，主库和从库之间相差了 `put d e` 和 `put d f` 两个操作，在增量复制时，主库只需要把它们同步给从库就行了。

说到这里，我们再借助一张图，回顾下增量复制的流程：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230226151913.png" alt="20230226151913" style="zoom:80%;" /></center>

不过由于 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。**如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致<u>主从库间的数据不一致</u>**。因此，我们要想办法避免这一情况，一般而言，我们可以调整 **repl_backlog_size** 这个参数。这个参数和所需的缓冲空间大小有关：缓冲空间大小 = 主库写入命令速度 \\* 操作大小 \- 主从库间网络传输命令速度 \\* 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl\_backlog\_size = 缓冲空间大小 \* 2，这也就是 repl_backlog_size 的最终值。

> 举个例子，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把 repl_backlog_size 设为 4MB。

这样一来，增量复制时主从库的数据不一致风险就降低了。不过，如果<u>并发请求量非常大</u>，连两倍的缓冲空间都存不下新操作请求的话，此时，<u>主从库数据仍然可能不一致</u>。针对这种情况：

- 一方面，根据服务器的资源继续适当增加 repl_backlog_size 值。
- 一方面，可以考虑使用切片集群来分担单个主库的请求压力。（后面会讲）

### 1.4 小结

这一节主要讲了 Redis 主从同步的三种模式：

1. 全量复制：第一次同步不可避免，耗时。为避免压力，引入了“主-从-从”的级联模式。
2. 长连接复制：是主从库正常运行后的常规同步阶段，主从之间通过命令传播实现同步。
3. 增量复制：发生网络断连后，就需要增量复制来保证数据的同步。

不过，主从模式面临主库故障的潜在风险，下面将聊聊主库故障后，保证服务可靠性的解决方案。

---

**本节问题：为什么主从库间的复制不使用 AOF**？

有两个原因：

1. RDB 文件是二进制文件，无论是要把 RDB 写入磁盘，还是要通过网络传输 RDB，IO 效率都比记录和传输 AOF 的高。
2. 在从库端进行恢复时，用 RDB 的恢复效率要高于用 AOF。
