---
title: 如何应对变慢的 Redis
date: 2023-04-08 21:28:19
permalink: /pages/f111bf/
categories:
  - 中间件
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [18 波动的响应延迟：如何应对变慢的Redis？（上）| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)
> + [19 波动的响应延迟：如何应对变慢的Redis？（下）| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

在实际部署中，有一个很严重的问题：Redis 突然变慢了，这可能会直接影响其他系统，导致一连串的连锁反应。本文将介绍<u>如何系统性地应对 Redis 变慢</u>这个问题，并<u>从问题认定、系统性排查和应对方案</u>这 3 个方面来进行讲解。

## 1. Redis 真的变慢了吗？

判断 Redis 是否真的变慢了有个最直接的方法：**查看 Redis 的响应延迟**。

大部分时候 Redis 延迟很低，但某些时刻可能会出现很高的相应延迟，甚至能达到几秒到十几秒，不过持续时间不长，这也叫**延迟毛刺**。当你发现 Redis 命令的执行时间突然就增长到了几秒，基本就可以认定 Redis 变慢了。

这种方法看的是 Redis 延迟的绝对值，但在不同的软硬件环境下，Redis 的绝对性能本身并不相同。比如差的机器延迟 1ms 才认定变慢了，但好的机器延迟 0.2ms 就可以认定变慢了。

所以需要第二个判断方法：**基于当前环境下的 Redis 基线性能做判断**。<mark>基线性能</mark>：指一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定。

具体如何确定基线性能呢？redis-cli 命令提供了 `–intrinsic-latency` 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 Redis 的基线性能。其中，测试时长可以用 –intrinsic-latency 选项的参数来指定。

举个例子，比如说，我们运行下面的命令，该命令会打印 120 秒内监测到的最大延迟。可以看到，这里的最大延迟是 119 微秒，也就是基线性能为 119 微秒。**一般情况下，运行 120 秒就足够监测到最大延迟了**，所以，我们可以把参数设置为 120。

```bash
./redis-cli --intrinsic-latency 120
Max latency so far: 17 microseconds.
Max latency so far: 44 microseconds.
Max latency so far: 94 microseconds.
Max latency so far: 110 microseconds.
Max latency so far: 119 microseconds.
36481658 total runs (avg latency: 3.2893 microseconds / 3289.32 nanoseconds per run).
Worst run took 36x longer than the average latency.
```

一般来说，你要把运行时延迟和基线性能进行对比，**如果你观察到的 Redis 运行时延迟是其基线性能的 2 倍及以上，就可以认定 Redis 变慢了**。

我们通常是通过客户端和网络访问Redis服务，为了避免网络对基线性能的影响，刚刚说的这个命令需要在服务器端直接运行，这也就是说，**我们只考虑服务器端软硬件环境的影响**。如果你想了解网络对Redis性能的影响，一个简单的方法是用 **iPerf** 这样的工具，测量从 Redis 客户端到服务器端的网络延迟。如果这个延迟有几十毫秒甚至是几百毫秒，就说明，Redis 运行的网络环境中很可能有大流量的其他应用程序在运行，导致网络拥塞了。这个时候，你就需要协调网络运维，调整网络的流量分配了。

## 2. 如何应对 Redis 变慢？

我们现在需要诊断 Redis 变慢的原因。要基于自己对Redis本身的工作原理的理解，并且结合和它交互的操作系统、存储以及网络等外部系统关键机制，再借助一些辅助工具来定位原因，并制定行之有效的解决方案。

下图是 Redis 的架构图，红色模块就是<u>影响 Redis 的三大要素</u>：Redis 自身的操作特性、文件系统和操作系统。

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230408215421.png" alt="20230408215421" style="zoom:75%;" /></center>

下面将从这三大要素入手，并结合实际的应用场景，依次介绍从不同要素出发排查和解决问题的实践经验。性能诊断通常是一件困难的事，所以我们一定不能毫无目标地“乱找”。

### 2.1 Redis 自身操作特性的影响

首先来学习下 Redis 提供的键值对命令操作对延迟性能的影响。这里重点介绍两类关键操作：慢查询命令和过期 key 操作。

#### 2.1.1 慢查询命令

<mark>慢查询命令</mark>：指在 Redis 中执行速度慢的命令，这会导致 Redis 延迟增加。

执行快慢与操作复杂度相关。比如说，Value 类型为 String 时，GET/SET 操作主要就是操作 Redis 的哈希表索引。这个操作复杂度基本是固定的，即 O(1)。但是，当 Value 类型为 Set 时，SORT、SUNION/SMEMBERS 操作复杂度分别为 O(N+M\*log(M)) 和 O(N) 。其中，N 为 Set 中的元素个数，M 为 SORT 操作返回的元素个数。这个复杂度就增加了很多。[Redis官方文档](https://redis.io/commands/) 中对每个命令的复杂度都有介绍，当你需要了解某个命令的复杂度时，可以直接查询。

<font color=blue>当你发现 Redis 性能变慢时，可以通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令</font>。如果的确<u>有大量的慢查询命令，有两种处理方式</u>：

1. **用其他高效命令代替**。比如说，如果你需要返回一个SET中的所有成员时，不要使用SMEMBERS命令，而是要使用SSCAN多次迭代返回，避免一次返回大量数据，造成线程阻塞。
2. **当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例**。

还有一个比较容易忽略的慢查询命令，就是 **KEYS**：用于返回和输入模式匹配的所有key。例如，以下命令返回所有包含“name”字符串的 keys：

```plain
redis> KEYS *name*
1) "lastname"
2) "firstname"
```

因为 KEYS 命令需要遍历存储的键值对，所以操作延时高。如果你不了解它的实现而使用了它，就会导致Redis性能变慢。所以，**KEYS命令一般不被建议用于生产环境中**。

#### 2.1.2 过期 key 操作

**过期 key 的自动删除机制**是 Redis 用来回收内存空间的常用机制，应用广泛，本身就会引起Redis操作阻塞，导致性能变慢，所以，你必须要知道该机制对性能的影响。

Redis 键值对的 key 可以设置过期时间。**默认情况下，Redis 每 100 毫秒会删除一些过期 key**，具体的算法如下：

1. 采样 ACTIVE\_EXPIRE\_CYCLE\_LOOKUPS\_PER\_LOOP 个数的 key，并将其中过期的 key 全部删除；
2. 如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。

> 上述 1 是会每秒都在执行的。

ACTIVE\_EXPIRE\_CYCLE\_LOOKUPS\_PER\_LOOP 是 Redis 的一个参数，默认是 20，那么，一秒内基本有 200 个过期 key 会被删除。这一策略对清除过期 key、释放内存空间很有帮助。如果每秒钟删除 200 个过期 key，并不会对 Redis 造成太大影响。

但是，如果触发了上面这个算法的第二条，Redis 就会一直删除以释放内存空间。注意，**删除操作是阻塞的**（Redis 4.0后可以用异步线程机制来减少阻塞影响）。所以，一旦该条件触发，Redis 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作了，就会进一步引起其他键值操作的延迟增加，Redis 就会变慢。

算法的第二条被触发的一个重要来源就是：**频繁使用带有相同时间参数的 EXPIREAT 命令设置过期 key**，这就会导致，在同一秒内有大量的 key 同时过期。这里我就要给出第二条排查建议和解决方法了：

<font color=blue>你要检查业务代码在使用 EXPIREAT 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 EXPIRE 命令给批量的 key 设置相同的过期秒数。因为，这都会造成大量 key 在同一时间过期，导致性能变慢</font>。

遇到这种情况时，千万不要嫌麻烦，你首先要根据实际业务的使用需求，决定 EXPIREAT 和 EXPIRE 的过期时间参数。其次，如果一批 key 的确是同时过期，你还可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，加上一个一定大小范围内的随机数，这样，既保证了 key 在一个邻近时间范围内被删除，又避免了同时过期造成的压力。

---

刚刚讲了从 Redis 自身命令操作层面排查的方案，但如果发现 Redis 有执行大量的慢查询命令，也没有同时删除大量过期 keys，那就要关注影响性能的其他机制了，也就是文件系统和操作系统：

+ 一方面，Redis 会持久化保存数据到磁盘，这个过程要依赖文件系统来完成，所以，文件系统将数据写回磁盘的机制，会直接影响到 Redis 持久化的效率。而且，在持久化的过程中，Redis 也还在接收其他请求，持久化的效率高低又会影响到 Redis 处理请求的性能。
+ 另一方面，Redis是内存数据库，内存操作非常频繁，所以，操作系统的内存机制会直接影响到 Redis 的处理效率。比如说，如果 Redis 的内存不够用了，操作系统会启动 swap 机制，这就会直接拖慢 Redis。
