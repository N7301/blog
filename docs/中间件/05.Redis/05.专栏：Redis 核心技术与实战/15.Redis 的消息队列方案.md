---
title: Redis 的消息队列方案
date: 2023-04-06 11:27:04
permalink: /pages/5d636a/
categories:
  - 中间件
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [15 消息队列的考验：Redis 有哪些解决方案？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

## 1. 消息队列的考验：Redis有哪些解决方案？

消息队列是分布式系统的基础软件，要能支持组件通信消息的快速读写。Redis 本身支持数据的高速访问，因此很多人关心一个问题：Redis 适合做 MQ 吗？

这个问题的背后，隐含着两方面的核心问题：

+ 消息队列的消息存取需求是什么？
+ Redis 如何实现消息队列的需求？

理解了 MQ 的特征和 Redis 提供的 MQ 方案，才能根据实际需求来选择出适合的 Redis 消息队列方案。

### 1.1 MQ 的消息存取需求

先介绍一下**消息队列存取消息的过程**。在分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。

一个通用的 MQ 的架构模型为：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406112919.png" alt="$uploadName" style="zoom:75%;" /></center>

消息队列中发送消息的组件称为<mark>生产者</mark>，接收消息的组件称为<mark>消费者</mark>。

在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是<font color=blue>消息队列作为分布式组件通信的一大优势</font>。

MQ 在存取消息时，必须要满足三个需求：

1. 消息保序
2. 处理重复的消息（幂等要求）
3. 保证消息可靠性

#### 需求一：消息保序

虽然消费者是**异步处理消息**，但是，**消费者仍然需要按照生产者发送消息的顺序来处理消息**，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。

我们来看一个更新商品库存的场景：假设生产者负责接收库存更新请求，消费者负责实际更新库存，现有库存量是10。生产者先后发送了消息1和消息2，消息1要把商品X的库存记录更新为5，消息2是把商品X库存更新为3。如果消息1和2在消息队列中无法保序，出现消息2早于消息1被处理的情况，那么，很显然，库存更新就出错了。这是业务应用无法接受的。

#### 需求二：重复消息处理（幂等要求）

消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。

比如可能出现重复扣款的问题。

#### 需求三：消息可靠性保证

消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。

Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。下面来看这两种方案。

### 1.2 基于 List 的 MQ 解决方案

#### 1.2.1 解决消息保序问题

List 本身就是按先进先出的顺序对数据进行存取的，所以如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了：

+ 生产者使用 <mark>LPUSH 命令</mark>把消息写入 List
+ 消费者使用 <mark>RPOP 命令</mark>读取消息

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406162435.png" alt="$uploadName" style="zoom:75%;" /></center>

不过这样的话 List 不会主动告知消费者有新消息的写入，这样就需要消费者一直调用 RPOP 来监听消息（比如使用一个while(1)循环），这会带来不必要的性能损失。

为了解决这个问题，Redis 提供了 <mark>BRPOP 命令</mark>：**阻塞式读取**，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。这种方式相比消费者不停调用 RPOP 而言，更加<u>节省 CPU 开销</u>。

#### 1.2.2 幂等性要求（处理重复消息）

解决消息重复问题，其实有一个要求：消费者程序本身能对重复消息进行判断：

+ 一方面，消息队列要能给每一个消息提供全局唯一的 ID 号；
+ 另一方面，消费者程序要把已经处理过的消息的 ID 号记录下来。

<mark>幂等性</mark>就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。

因为 List 本身不会为消息生成 ID 号，因此<font color=blue>需要生产者在发送消息时附带上全局唯一 ID</font>。例如，我们执行以下命令，就把一条全局 ID 为 101030001、库存量为 5 的消息插入了消息队列：

```plain
LPUSH mq "101030001:stock:5"
(integer) 1
```

#### 1.2.3 消息可靠性保证

当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。

为了留存消息，List 类型提供了 <mark>BRPOPLPUSH 命令</mark>，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。下图是使用 BRPOPLPUSH 命令留存消息，以及消费者再次读取消息的过程：

<center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230406163205.png" alt="$uploadName" style="zoom:75%;" /></center>

好了，到这里你可以看到，基于 List 类型，我们可以满足分布式组件对消息队列的三大需求。但是，在用 List 做消息队列时，我们还可能遇到过一个问题：**生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力**。这个时候，我们希望启动多个消费者程序组成一个**消费组**，一起分担处理 List 中的消息。但是，List 类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢？这就要说到 Redis 从 5.0 版本开始提供的 Streams 数据类型了。

和 List 相比，Streams 同样能够满足消息队列的三大需求。而且，它还支持消费组形式的消息读取。接下来，我们就来了解下 Streams 的使用方法。

### 1.3 基于 Streams 的消息队列解决方案

<mark>Streams</mark> 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令：

+ XADD：插入消息，保证有序，可以自动生成全局唯一 ID；
+ XREAD：用于读取消息，可以按 ID 读取数据；
+ XREADGROUP：按消费组形式读取消息；
+ XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。

