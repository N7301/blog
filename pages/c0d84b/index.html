<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>YAML、Pod、Job、CronJob、ConfigMap、Secret | Nrich&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/blog/img/bitbug_favicon.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.5e70c998.css" as="style"><link rel="preload" href="/blog/assets/js/app.73302609.js" as="script"><link rel="preload" href="/blog/assets/js/2.c02cd514.js" as="script"><link rel="preload" href="/blog/assets/js/58.52fb51c8.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ccc2fc76.js"><link rel="prefetch" href="/blog/assets/js/11.15e920f7.js"><link rel="prefetch" href="/blog/assets/js/12.d6b747fb.js"><link rel="prefetch" href="/blog/assets/js/13.ee8d04f3.js"><link rel="prefetch" href="/blog/assets/js/14.b7513ca5.js"><link rel="prefetch" href="/blog/assets/js/15.f2e8ff40.js"><link rel="prefetch" href="/blog/assets/js/16.347a6e24.js"><link rel="prefetch" href="/blog/assets/js/17.6c1e9625.js"><link rel="prefetch" href="/blog/assets/js/18.7602b54c.js"><link rel="prefetch" href="/blog/assets/js/19.8f4fcc4b.js"><link rel="prefetch" href="/blog/assets/js/20.09885064.js"><link rel="prefetch" href="/blog/assets/js/21.b525f277.js"><link rel="prefetch" href="/blog/assets/js/22.b9ed6df2.js"><link rel="prefetch" href="/blog/assets/js/23.523e5d22.js"><link rel="prefetch" href="/blog/assets/js/24.d04239a4.js"><link rel="prefetch" href="/blog/assets/js/25.237a6c47.js"><link rel="prefetch" href="/blog/assets/js/26.6bd9bfe4.js"><link rel="prefetch" href="/blog/assets/js/27.ac60ace0.js"><link rel="prefetch" href="/blog/assets/js/28.ee14024f.js"><link rel="prefetch" href="/blog/assets/js/29.0caa2b3a.js"><link rel="prefetch" href="/blog/assets/js/3.620a1f91.js"><link rel="prefetch" href="/blog/assets/js/30.e6e7d6f8.js"><link rel="prefetch" href="/blog/assets/js/31.6ec6039c.js"><link rel="prefetch" href="/blog/assets/js/32.37f8dd2f.js"><link rel="prefetch" href="/blog/assets/js/33.7e29804a.js"><link rel="prefetch" href="/blog/assets/js/34.8eeb5b9d.js"><link rel="prefetch" href="/blog/assets/js/35.72aa34f7.js"><link rel="prefetch" href="/blog/assets/js/36.9de84a28.js"><link rel="prefetch" href="/blog/assets/js/37.64e3dd13.js"><link rel="prefetch" href="/blog/assets/js/38.99ad5507.js"><link rel="prefetch" href="/blog/assets/js/39.8cda7b61.js"><link rel="prefetch" href="/blog/assets/js/4.0df20a49.js"><link rel="prefetch" href="/blog/assets/js/40.ed6949c0.js"><link rel="prefetch" href="/blog/assets/js/41.bf343b6b.js"><link rel="prefetch" href="/blog/assets/js/42.cbbfd0d9.js"><link rel="prefetch" href="/blog/assets/js/43.39209b19.js"><link rel="prefetch" href="/blog/assets/js/44.7eec5b18.js"><link rel="prefetch" href="/blog/assets/js/45.b088db4c.js"><link rel="prefetch" href="/blog/assets/js/46.bfc9e511.js"><link rel="prefetch" href="/blog/assets/js/47.d0b2aa80.js"><link rel="prefetch" href="/blog/assets/js/48.49b8f1b4.js"><link rel="prefetch" href="/blog/assets/js/49.72f6d0a1.js"><link rel="prefetch" href="/blog/assets/js/5.94069b5e.js"><link rel="prefetch" href="/blog/assets/js/50.dcbe6aa5.js"><link rel="prefetch" href="/blog/assets/js/51.cca2da80.js"><link rel="prefetch" href="/blog/assets/js/52.063ad237.js"><link rel="prefetch" href="/blog/assets/js/53.65573113.js"><link rel="prefetch" href="/blog/assets/js/54.e3b86f9a.js"><link rel="prefetch" href="/blog/assets/js/55.e23d17b7.js"><link rel="prefetch" href="/blog/assets/js/56.c47badfb.js"><link rel="prefetch" href="/blog/assets/js/57.8c7d3e16.js"><link rel="prefetch" href="/blog/assets/js/59.8ee7423a.js"><link rel="prefetch" href="/blog/assets/js/6.90726693.js"><link rel="prefetch" href="/blog/assets/js/60.7c6906fd.js"><link rel="prefetch" href="/blog/assets/js/61.898384c1.js"><link rel="prefetch" href="/blog/assets/js/62.6bf3cdda.js"><link rel="prefetch" href="/blog/assets/js/63.fed7f6ff.js"><link rel="prefetch" href="/blog/assets/js/64.62128c79.js"><link rel="prefetch" href="/blog/assets/js/65.dd8213b3.js"><link rel="prefetch" href="/blog/assets/js/66.579f1a82.js"><link rel="prefetch" href="/blog/assets/js/67.fa647f5d.js"><link rel="prefetch" href="/blog/assets/js/68.d535a10d.js"><link rel="prefetch" href="/blog/assets/js/69.4d7e0d52.js"><link rel="prefetch" href="/blog/assets/js/7.ba20b3c7.js"><link rel="prefetch" href="/blog/assets/js/70.4b6cd449.js"><link rel="prefetch" href="/blog/assets/js/71.be36a223.js"><link rel="prefetch" href="/blog/assets/js/72.f57cde07.js"><link rel="prefetch" href="/blog/assets/js/73.a4087adf.js"><link rel="prefetch" href="/blog/assets/js/74.8f60ef05.js"><link rel="prefetch" href="/blog/assets/js/75.fdc945ab.js"><link rel="prefetch" href="/blog/assets/js/76.d1f1faa5.js"><link rel="prefetch" href="/blog/assets/js/77.687a6763.js"><link rel="prefetch" href="/blog/assets/js/78.97f56bb1.js"><link rel="prefetch" href="/blog/assets/js/79.35c1de5f.js"><link rel="prefetch" href="/blog/assets/js/8.2abb0131.js"><link rel="prefetch" href="/blog/assets/js/80.fbe50656.js"><link rel="prefetch" href="/blog/assets/js/81.102e33bc.js"><link rel="prefetch" href="/blog/assets/js/82.4f73285b.js"><link rel="prefetch" href="/blog/assets/js/9.ece9abdb.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5e70c998.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/mylogo.jpeg" alt="Nrich's blog" class="logo"> <span class="site-name can-hide">Nrich's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><!----> <span class="title" style="display:;">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">Golang</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AI" class="dropdown-title"><!----> <span class="title" style="display:;">AI</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/deep-learning/" class="nav-link">深度学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/blog/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/datastructure/" class="nav-link">DataStructure</a></li><li class="dropdown-item"><!----> <a href="/blog/cloudnative/" class="nav-link">CloudNative</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><!----> <span class="title" style="display:;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/blog/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><!----> <span class="title" style="display:;">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/route-hijack/" class="nav-link">路由劫持</a></li></ul></div></div> <a href="https://github.com/n7301/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/head.jpg"> <div class="blogger-info"><h3>Nrich</h3> <span>小聪明</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><!----> <span class="title" style="display:;">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">Golang</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AI" class="dropdown-title"><!----> <span class="title" style="display:;">AI</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/deep-learning/" class="nav-link">深度学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/blog/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/datastructure/" class="nav-link">DataStructure</a></li><li class="dropdown-item"><!----> <a href="/blog/cloudnative/" class="nav-link">CloudNative</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><!----> <span class="title" style="display:;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/blog/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><!----> <span class="title" style="display:;">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/route-hijack/" class="nav-link">路由劫持</a></li></ul></div></div> <a href="https://github.com/n7301/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>云原生</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Kubernetes入门实战课-罗剑锋</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/850e00/" class="sidebar-link">开篇词</a></li><li><a href="/blog/pages/1cc8db/" class="sidebar-link">初识容器</a></li><li><a href="/blog/pages/757154/" class="sidebar-link">Kubernetes 的安装与基本架构</a></li><li><a href="/blog/pages/c0d84b/" aria-current="page" class="active sidebar-link">YAML、Pod、Job、CronJob、ConfigMap、Secret</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/c0d84b/#_1-yaml-kubernetes世界里的通用语" class="sidebar-link">1. YAML：Kubernetes世界里的通用语</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_1-1-声明式与命令式是怎么回事" class="sidebar-link">1.1 声明式与命令式是怎么回事</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_1-2-什么是-yaml" class="sidebar-link">1.2 什么是 YAML</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_1-3-什么是-api-对象" class="sidebar-link">1.3 什么是 API 对象</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_1-4-如何描述api对象" class="sidebar-link">1.4 如何描述API对象</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_1-5-如何编写-yaml" class="sidebar-link">1.5 如何编写 YAML</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_1-6-课外小贴士" class="sidebar-link">1.6 课外小贴士</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/c0d84b/#_2-pod-如何理解这个kubernetes里最核心的概念" class="sidebar-link">2. Pod：如何理解这个Kubernetes里最核心的概念？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_2-1-为什么要有-pod" class="sidebar-link">2.1 为什么要有 Pod</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/c0d84b/#_3-job-cronjob-为什么不直接用pod来处理业务" class="sidebar-link">3. Job/CronJob：为什么不直接用Pod来处理业务？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_3-1-为什么不直接使用pod" class="sidebar-link">3.1 为什么不直接使用Pod</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#小结" class="sidebar-link">小结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/c0d84b/#_4-configmap-secret-怎样配置、定制我的应用" class="sidebar-link">4. ConfigMap/Secret：怎样配置、定制我的应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_4-1-configmap-secret" class="sidebar-link">4.1 ConfigMap/Secret</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/c0d84b/#_4-1-1-什么是configmap" class="sidebar-link">4.1.1 什么是ConfigMap</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/c0d84b/#_4-1-2-什么是secret" class="sidebar-link">4.1.2 什么是Secret</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_4-2-如何使用" class="sidebar-link">4.2 如何使用</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/c0d84b/#_4-2-1-以环境变量的方式使用" class="sidebar-link">4.2.1 以环境变量的方式使用</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/c0d84b/#_4-2-2-以volume的方式使用" class="sidebar-link">4.2.2 以Volume的方式使用</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/c0d84b/#_4-3-小结" class="sidebar-link">4.3 小结</a></li></ul></li></ul></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/categories/?category=%E5%9F%BA%E7%A1%80" title="分类" data-v-06225672>基础</a></li><li data-v-06225672><a href="/blog/categories/?category=%E4%BA%91%E5%8E%9F%E7%94%9F" title="分类" data-v-06225672>云原生</a></li><li data-v-06225672><a href="/blog/categories/?category=Kubernetes%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E8%AF%BE-%E7%BD%97%E5%89%91%E9%94%8B" title="分类" data-v-06225672>Kubernetes入门实战课-罗剑锋</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/Nrich-sunny" target="_blank" title="作者" class="beLink" data-v-06225672>Nrich</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-06</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">YAML、Pod、Job、CronJob、ConfigMap、Secret<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="_1-yaml-kubernetes世界里的通用语"><a href="#_1-yaml-kubernetes世界里的通用语" class="header-anchor">#</a> 1. YAML：Kubernetes世界里的通用语</h2> <p>Kubernetes世界里的标准工作语言是 YAML。</p> <h3 id="_1-1-声明式与命令式是怎么回事"><a href="#_1-1-声明式与命令式是怎么回事" class="header-anchor">#</a> 1.1 声明式与命令式是怎么回事</h3> <blockquote><p>YAML 是“声明式”。</p></blockquote> <p>Docker命令和Dockerfile就属于“<mark>命令式</mark>”，大多数编程语言也属于命令式，它的特点是交互性强，注重顺序和过程，你必须“告诉”计算机每步该做什么，所有的步骤都列清楚，这样程序才能够一步步走下去，最后完成任务，显得计算机有点“笨”。</p> <p>“<mark>声明式</mark>”，在Kubernetes出现之前比较少见，它与“命令式”完全相反，不关心具体的过程，更注重结果。我们不需要“教”计算机该怎么做，只要告诉它一个目标状态，它自己就会想办法去完成任务，相比起来自动化、智能化程度更高。</p> <p>以“打车”来形象地解释一下“命令式”和“声明式”的区别。</p> <ul><li>假设你要打车去高铁站，但司机不熟悉路况，你就只好不厌其烦地告诉他该走哪条路、在哪个路口转向、在哪里进出主路、停哪个站口。虽然最后到达了目的地，但这一路上也费了很多口舌，发出了无数的“命令”。很显然，这段路程就属于“命令式”。</li> <li>同样是去高铁站，但司机经验丰富，他知道哪里有拥堵、哪条路的红绿灯多、哪段路有临时管控、哪里可以抄小道，此时你再多嘴无疑会干扰他的正常驾驶，所以，你只要给他一个“声明”：我要去高铁站，接下来就可以舒舒服服地躺在后座上休息，顺利到达目的地了</li></ul> <p>在这个“打车”的例子里，Kubernetes就是这样的一位熟练的司机，Master/Node架构让它对整个集群的状态了如指掌，内部的众多组件和插件也能够自动监控管理应用。我们最好是做一个“ <strong>甩手掌柜</strong>”，用“声明式”把任务的目标告诉它，比如使用哪个镜像、什么时候运行，让它自己去处理执行过程中的细节。</p> <p>那么，YAML 语言就是给 Kubernetes 发出一个“声明”的方式。</p> <blockquote><p>容器技术里的Shell脚本和Dockerfile可以很好地描述“命令式”，但对于“声明式”就不太合适了</p></blockquote> <h3 id="_1-2-什么是-yaml"><a href="#_1-2-什么是-yaml" class="header-anchor">#</a> 1.2 什么是 YAML</h3> <blockquote><p>YAML v.s. XML:</p> <ul><li>XML 是一种类似 HTML 的标签式语言，有很多繁文缛节。</li> <li>YAML 实质上与XML完全不同，更适合人类阅读，计算机解析起来也很容易</li></ul></blockquote> <p>把YAML的数组、对象组合起来，我们就可以描述出任意的Kubernetes资源对象。</p> <h3 id="_1-3-什么是-api-对象"><a href="#_1-3-什么是-api-对象" class="header-anchor">#</a> 1.3 什么是 API 对象</h3> <p>YAML语言只相当于“语法”，要与Kubernetes对话，我们还必须有足够的“词汇”来表示“语义”。作为一个集群操作系统，Kubernetes归纳总结了Google多年的经验，在理论层面抽象出了很多个概念，用来描述系统的管理运维工作，这些概念就叫做“ <strong><mark>API对象</mark></strong>”。</p> <p>说到这个名字，你也许会联想到上次课里讲到的Kubernetes组件 <strong>apiserver</strong>。没错，它正是来源于此。因为apiserver是Kubernetes系统的唯一入口，外部用户和内部组件都必须和它通信，而它采用了HTTP协议的URL资源理念，API风格也用RESTful的GET/POST/DELETE等等，所以，这些概念很自然地就被称为是“API对象”了。</p> <p><strong>那都有哪些API对象呢？</strong></p> <p>使用 <code>kubectl api-resources</code> 来查看当前Kubernetes版本支持的所有对象：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl api-resources
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230606214149.png" alt="$uploadName" style="zoom:75%;"></center> <p>在输出的“NAME”一栏，就是对象的名字，比如ConfigMap、Pod、Service等等，第二栏“SHORTNAMES”则是这种资源的简写，在我们使用kubectl命令的时候很有用，可以少敲几次键盘，比如Pod可以简写成po，Service可以简写成svc。</p> <p>在使用kubectl命令的时候，你还可以加上一个参数 <code>--v=9</code>，它会显示出详细的命令执行过程，清楚地看到发出的HTTP请求，比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl get pod <span class="token parameter variable">--v</span><span class="token operator">=</span><span class="token number">9</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230606214343.png" alt="$uploadName" style="zoom:75%;"></center> <p>从截图里可以看到，kubectl客户端等价于调用了curl，向8443端口发送了HTTP GET 请求，URL是 <code>/api/v1/namespaces/default/pods</code>。</p> <p>目前的Kubernetes 1.23版本有50多种API对象，全面地描述了集群的节点、应用、配置、服务、账号等等信息，apiserver会把它们都存储在数据库etcd里，然后kubelet、scheduler、controller-manager等组件通过apiserver来操作它们，就在API对象这个抽象层次实现了对整个集群的管理。</p> <h3 id="_1-4-如何描述api对象"><a href="#_1-4-如何描述api对象" class="header-anchor">#</a> 1.4 如何描述API对象</h3> <blockquote><p>Kubernetes把集群里的一切资源都定义为API对象，通过RESTful接口来管理。描述API对象需要使用YAML语言，必须的字段是 <strong>apiVersion、kind、metadata</strong>。</p></blockquote> <p>之前我们使用 kubectl 运行 nginx 的命令用的是命令式的 <code>kubectl run</code>：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl run ngx <span class="token parameter variable">--image</span><span class="token operator">=</span>nginx:alpine
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>下面看一下如何以 YAML 语言来声明式地在 k8s 中描述并创建 API 对象。在 YAML 中，我们需要说清楚我们的目标状态，让 Kubernetes 自己去决定如何拉取镜像并运行：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> ngx<span class="token punctuation">-</span>pod
  labels<span class="token punctuation">:</span>
    env<span class="token punctuation">:</span> demo
    owner<span class="token punctuation">:</span> nrich

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  containers<span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    name<span class="token punctuation">:</span> ngx
    ports<span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看出，这里是创建一个 pod，要使用 nginx:alpine 的 image 来创建一个 container，并开放 80 端口，而其他部分就是 k8s 对 API 对象强制的格式要求了。</p> <p>因为API对象采用标准的 HTTP 协议，为了方便理解，我们可以借鉴一下 HTTP 的报文格式，<strong>把 API 对象的描述分成“header”和“body”两部分</strong>。</p> <p>header 包含的是 API 对象的基本信息，有三个字段：</p> <ul><li><strong>apiVersion</strong>：表示操作这种资源的 API 版本号，由于 Kubernetes 的迭代速度很快，不同的版本创建的对象会有差异，为了区分这些版本就需要使用 apiVersion 这个字段，比如 v1、v1alpha1、v1beta1 等等。</li> <li><strong>kind</strong>：表示资源对象的类型，比如 Pod、Node、Job、Service 等。</li> <li><strong>metadata</strong>：表示的是资源的一些元信息，也就是用来标记对象，方便 Kubernetes 管理的一些信息。在上面的示例中有两个元信息：
<ul><li>name：给 pod 起了个名字</li> <li>labels：给 pod 贴上一些便于查找的标签，分别是 <code>env</code> 和 <code>owner</code>。</li></ul></li></ul> <p>以上信息都被 kubectl 用于生成 HTTP 请求发给 apiserver，你可以用 <code>--v=9</code> 参数在请求的 URL 里看到它们，比如：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>https://192.168.49.2:8443/api/v1/namespaces/default/pods/ngx-pod
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>header 中的 apiVersion、kind、metadata 这三个字段都是任何对象都必须有的</strong>，而 body 部分则会与对象特定相关，每种对象会有不同的规格定义，<strong>在 YAML 里就表现为 <code>spec</code> 字段（即 specification）</strong>，表示我们对对象的“期望状态”（desired status）。</p> <p>还是来看这个 Pod，它的 spec 里就是一个 <code>containers</code> 数组，里面的每个元素又是一个对象，指定了名字、镜像、端口等信息：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  containers<span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    name<span class="token punctuation">:</span> ngx
    ports<span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>现在把这些字段综合起来，我们就能够看出，这份 YAML 文档完整地描述了一个类型是 Pod 的 API 对象，要求使用 v1 版本的 API 接口去管理，其他更具体的名称、标签、状态等细节都记录在了 metadata 和 spec 字段等里。</p> <p>使用 <code>kubectl apply</code>、 <code>kubectl delete</code>，再加上参数 <code>-f</code>，你就可以使用这个 YAML 文件，创建或者删除对象了：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl apply <span class="token parameter variable">-f</span> ngx-pod.yml    <span class="token comment"># 创建 API 对象</span>
kubectl delete <span class="token parameter variable">-f</span> ngx-pod.yml   <span class="token comment"># 删除 API 对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Kubernetes 收到这份“声明式”的数据，再根据 HTTP 请求里的 POST/DELETE 等方法，就会自动操作这个资源对象，至于对象在哪个节点上、怎么创建、怎么删除完全不用我们操心。</p> <h3 id="_1-5-如何编写-yaml"><a href="#_1-5-如何编写-yaml" class="header-anchor">#</a> 1.5 如何编写 YAML</h3> <p>这么多字段，我们怎样才能编写正确的 YAML 呢？</p> <p>这个问题的最权威的答案自然是 k8s 的<a href="https://kubernetes.io/docs/reference/kubernetes-api/" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，API 对象的所有字段都可以在里面找到。但这内容太多，下面介绍一些实用的小技巧。</p> <p><strong>第一个技巧</strong>其实前面已经说过了，就是 <code>kubectl api-resources</code> 命令，它会显示出资源对象相应的API版本和类型，比如Pod的版本是“v1”，Ingress的版本是“networking.k8s.io/v1”，照着它写绝对不会错。</p> <p><strong>第二个技巧</strong>，是命令 <code>kubectl explain</code>，它相当于是Kubernetes自带的API文档，会给出对象字段的详细说明，这样我们就不必去网上查找了。比如想要看Pod里的字段该怎么写，就可以这样：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl explain pod
kubectl explain pod.metadata
kubectl explain pod.spec
kubectl explain pod.spec.containers
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>使用前两个技巧编写 YAML 就基本上没有难度了。</p> <p>⭐️ <strong>第三个技巧</strong>就是kubectl的两个特殊参数 <code>--dry-run=client</code> 和 <code>-o yaml</code>，前者是空运行，后者是生成YAML格式，<strong>结合起来使用就会让 kubectl 不会有实际的创建动作，而只生成 YAML 文件</strong>。例如，想要生成一个Pod的YAML样板示例，可以在 <code>kubectl run</code> 后面加上这两个参数：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl run ngx <span class="token parameter variable">--image</span><span class="token operator">=</span>nginx:alpine --dry-run<span class="token operator">=</span>client <span class="token parameter variable">-o</span> yaml
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>就会生成一个绝对正确的 YAML 文件：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  creationTimestamp<span class="token punctuation">:</span> <span class="token null important">null</span>
  labels<span class="token punctuation">:</span>
    run<span class="token punctuation">:</span> ngx
  name<span class="token punctuation">:</span> ngx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  containers<span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    name<span class="token punctuation">:</span> ngx
    resources<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  dnsPolicy<span class="token punctuation">:</span> ClusterFirst
  restartPolicy<span class="token punctuation">:</span> Always
<span class="token key atrule">status</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>接下来你要做的，就是查阅对象的说明文档，添加或者删除字段来定制这个 YAML 了。</p> <p>这个小技巧还可以再进化一下，把这段参数定义成Shell变量（名字任意，比如<code>$do</code>/<code>$go</code>，这里用的是 <code>$out</code>），用起来会更省事，比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token assign-left variable">out</span><span class="token operator">=</span><span class="token string">&quot;--dry-run=client -o yaml&quot;</span>
kubectl run ngx <span class="token parameter variable">--image</span><span class="token operator">=</span>nginx:alpine <span class="token variable">$out</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>今后除了一些特殊情况，我们都不会再使用 <code>kubectl run</code> 这样的命令去直接创建 Pod，而是会编写 YAML，用“声明式”来描述对象，再用 <code>kubectl apply</code> 去发布 YAML 来创建对象。</p> <h3 id="_1-6-课外小贴士"><a href="#_1-6-课外小贴士" class="header-anchor">#</a> 1.6 课外小贴士</h3> <ul><li>.推荐一个知名的 JSON/YAML 工具网站: <a href="https://www.bejson.com/" target="_blank" rel="noopener noreferrer">BEJSON<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，支持 JSON 格式校验也可以转换 YAML。</li> <li>Kubernetes 的 API 版本命名有明确规范，正式版本(GA，Generally available) 是 v1 这样的纯数字，试验性质、不稳定的是 alpha,比较稳定、即将发布的是 beta。</li> <li>因为 Kubernetes 的开发语言是 Go，所以 API 对象字段用的都是 Go 语法规范，例如字段命名遵循“Camel Case”，类型是 boolean、string、[]Object 等。</li></ul> <h2 id="_2-pod-如何理解这个kubernetes里最核心的概念"><a href="#_2-pod-如何理解这个kubernetes里最核心的概念" class="header-anchor">#</a> 2. Pod：如何理解这个Kubernetes里最核心的概念？</h2> <h3 id="_2-1-为什么要有-pod"><a href="#_2-1-为什么要有-pod" class="header-anchor">#</a> 2.1 为什么要有 Pod</h3> <p>Pod这个词原意是“豌豆荚”，后来又延伸出“舱室”“太空舱”等含义，形象地来说Pod就是包含了很多组件、成员的一种结构。</p> <p><strong>为了解决多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个“收纳舱”</strong>，让多个容器既保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态。</p> <p>所以，出现了Pod的概念，容器正是“豆荚”里那些小小的“豌豆”，你可以在Pod的YAML里看到，“spec.containers”字段其实是一个数组，里面允许定义多个容器。Pod 能让进程住得更舒服。</p> <p>TODO: 待补充</p> <h2 id="_3-job-cronjob-为什么不直接用pod来处理业务"><a href="#_3-job-cronjob-为什么不直接用pod来处理业务" class="header-anchor">#</a> 3. Job/CronJob：为什么不直接用Pod来处理业务？</h2> <p>Kubernetes的核心对象Pod，用来编排一个或多个容器，让这些容器共享网络、存储等资源，总是共同调度，从而紧密协同工作。Pod比容器更能够表示实际的应用，所以Kubernetes不会在容器层面来编排业务，而是把Pod作为在集群里调度运维的最小单位。</p> <p>前面我们也看到了一张Kubernetes的资源对象关系图，以Pod为中心，延伸出了很多表示各种业务的其他资源对象。那么你会不会有这样的疑问：Pod的功能已经足够完善了，为什么还要定义这些额外的对象呢？为什么不直接在Pod里添加功能，来处理业务需求呢？</p> <p>这个问题体现了Google对大规模计算集群管理的深度思考，今天我就说说Kubernetes基于Pod的设计理念，先从最简单的两种对象——Job和CronJob讲起。</p> <h3 id="_3-1-为什么不直接使用pod"><a href="#_3-1-为什么不直接使用pod" class="header-anchor">#</a> 3.1 为什么不直接使用Pod</h3> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>好了，今天我们以面向对象思想分析了一下Kubernetes里的资源对象设计，它强调“职责单一”和“对象组合”，简单来说就是“对象套对象”。</p> <p>通过这种嵌套方式，Kubernetes里的这些API对象就形成了一个“控制链”：</p> <p>CronJob使用定时规则控制Job，Job使用并发数量控制Pod，Pod再定义参数控制容器，容器再隔离控制进程，进程最终实现业务功能，层层递进的形式有点像设计模式里的Decorator（装饰模式），链条里的每个环节都各司其职，在Kubernetes的统一指挥下完成任务。</p> <p>小结一下今天的内容：</p> <ol><li>Pod是Kubernetes的最小调度单元，但为了保持它的独立性，不应该向它添加多余的功能。</li> <li>Kubernetes为离线业务提供了Job和CronJob两种API对象，分别处理“临时任务”和“定时任务”。</li> <li>Job的关键字段是 <code>spec.template</code>，里面定义了用来运行业务的Pod模板，其他的重要字段有 <code>completions</code>、 <code>parallelism</code> 等</li> <li>CronJob的关键字段是 <code>spec.jobTemplate</code> 和 <code>spec.schedule</code>，分别定义了Job模板和定时运行的规则。</li></ol> <h2 id="_4-configmap-secret-怎样配置、定制我的应用"><a href="#_4-configmap-secret-怎样配置、定制我的应用" class="header-anchor">#</a> 4. ConfigMap/Secret：怎样配置、定制我的应用</h2> <p>本节要解决的问题：使用 YAML 语言来定义 API 对象，再组合起来实现动态配置。</p> <p>下面讲解Kubernetes里专门用来管理配置信息的两种对象： <strong>ConfigMap</strong> 和 <strong>Secret</strong>，使用它们来灵活地配置、定制我们的应用。</p> <h3 id="_4-1-configmap-secret"><a href="#_4-1-configmap-secret" class="header-anchor">#</a> 4.1 ConfigMap/Secret</h3> <p>首先你要知道，应用程序有很多类别的配置信息，但从数据安全的角度来看可以分成两类：</p> <ul><li>一类是明文配置，也就是不保密，可以任意查询修改，比如服务端口、运行参数、文件路径等等。</li> <li>另一类则是机密配置，由于涉及敏感信息需要保密，不能随便查看，比如密码、密钥、证书等等。</li></ul> <p>这两类配置信息本质上都是字符串，只是由于安全性的原因，在存放和使用方面有些差异，所以Kubernetes也就定义了两个API对象， <strong>ConfigMap</strong> 用来保存明文配置， <strong>Secret</strong> 用来保存秘密配置。</p> <h4 id="_4-1-1-什么是configmap"><a href="#_4-1-1-什么是configmap" class="header-anchor">#</a> 4.1.1 什么是ConfigMap</h4> <p>ConfigMap 的简写：“cm”，后面都可以直接用简写代替。用命令 <code>kubectl create</code> 来创建一个它的YAML样板。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token assign-left variable">out</span><span class="token operator">=</span><span class="token string">&quot;--dry-run=client -o yaml&quot;</span>        <span class="token comment"># 定义Shell变量</span>
kubectl create cm info <span class="token punctuation">[</span>--from-literal<span class="token operator">=</span>k<span class="token operator">=</span>v<span class="token punctuation">]</span> <span class="token variable">$out</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>参数 <code>--from-literal=k=v</code> 是表示要生成带有“data”字段的YAML样板。<strong>注意，因为在ConfigMap里的数据都是Key-Value结构，所以 <code>--from-literal</code> 参数需要使用 <code>k=v</code> 的形式。</strong></p> <p>得到的样板文件大概是这个样子：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> info
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  <span class="token key atrule">k</span><span class="token punctuation">:</span> v
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>把YAML样板文件修改一下，再多增添一些Key-Value，就得到了一个比较完整的ConfigMap对象：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> info

<span class="token key atrule">data</span><span class="token punctuation">:</span>
  count<span class="token punctuation">:</span> <span class="token string">'10'</span>
  debug<span class="token punctuation">:</span> <span class="token string">'on'</span>
  path<span class="token punctuation">:</span> <span class="token string">'/etc/systemd'</span>
  greeting<span class="token punctuation">:</span> <span class="token punctuation">|</span>
    say hello to kubernetes.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>现在就可以使用 <code>kubectl apply</code> 把这个YAML交给Kubernetes，让它创建ConfigMap对象了：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl apply <span class="token parameter variable">-f</span> cm.yml
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>创建成功后，我们还是可以用 <code>kubectl get</code>、 <code>kubectl describe</code> 来查看ConfigMap的状态：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl get cm
kubectl describe cm info
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230609103910.png" alt="$uploadName" style="zoom:75%;"></center> <p>你可以看到，现在ConfigMap的Key-Value信息就已经存入了etcd数据库，后续就可以被其他API对象使用。</p> <h4 id="_4-1-2-什么是secret"><a href="#_4-1-2-什么是secret" class="header-anchor">#</a> 4.1.2 什么是Secret</h4> <p>Secret 和ConfigMap的结构和用法很类似，不过在Kubernetes里Secret对象又细分出很多类，比如：</p> <ul><li>访问私有镜像仓库的认证信息</li> <li>身份识别的凭证信息</li> <li>HTTPS通信的证书和私钥</li> <li>一般的机密信息（格式由用户自行解释）</li></ul> <p>前几种我们现在暂时用不到，所以就只使用最后一种，创建YAML样板的命令是 <code>kubectl create secret generic</code> ，同样，也要使用参数 <code>--from-literal</code> 给出Key-Value值：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl create secret generic user --from-literal<span class="token operator">=</span>name<span class="token operator">=</span>root <span class="token variable">$out</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>得到的Secret对象大概是这个样子：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> user

<span class="token key atrule">data</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> cm9vdA==

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Secret对象只是“kind”字段由“ConfigMap”变成了“Secret”，后面同样也是“data”字段，里面也是Key-Value的数据。但Secret 不能像ConfigMap那样直接保存明文了，对数据使用了 BASE64 编码（根本算不上真正的加密）。所以 Secret 对象不让用户直接看到原始数据，起到一定的保密作用。</p> <details class="custom-block details"><summary>自己用Linux工具对数据进行 base64 编码</summary> <p>我们完全可以绕开kubectl，自己用Linux小工具“base64”来对数据编码，然后写入YAML文件，比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">&quot;123456&quot;</span> <span class="token operator">|</span> base64
MTIzNDU2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要注意这条命令里的 <code>echo</code> ，必须要加参数 <code>-n</code> 去掉字符串里隐含的换行符，否则Base64编码出来的字符串就是错误的。</p></details> <p>我们再来重新编辑Secret的YAML，为它添加两个新的数据，方式可以是参数 <code>--from-literal</code> 自动编码，也可以是自己手动编码：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> user

<span class="token key atrule">data</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> cm9vdA==  <span class="token comment"># root</span>
  pwd<span class="token punctuation">:</span> MTIzNDU2   <span class="token comment"># 123456</span>
  db<span class="token punctuation">:</span> bXlzcWw=    <span class="token comment"># mysql</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>接下来的创建和查看对象操作和ConfigMap是一样的，使用 <code>kubectl apply</code>、 <code>kubectl get</code>、 <code>kubectl describe</code>：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl apply  <span class="token parameter variable">-f</span> secret.yml
kubectl get secret
kubectl describe secret user

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230609104516.png" alt="$uploadName" style="zoom:75%;"></center> <p>这样一个存储敏感信息的Secret对象也就创建好了，而且因为它是保密的，使用 <code>kubectl describe</code> 不能直接看到内容，只能看到数据的大小，你可以和ConfigMap对比一下。</p> <h3 id="_4-2-如何使用"><a href="#_4-2-如何使用" class="header-anchor">#</a> 4.2 如何使用</h3> <h4 id="_4-2-1-以环境变量的方式使用"><a href="#_4-2-1-以环境变量的方式使用" class="header-anchor">#</a> 4.2.1 以环境变量的方式使用</h4> <p>下面我就把引用了ConfigMap和Secret对象的Pod列出来，给你做个示范，为了提醒你注意，我把“ <strong>env</strong>”字段提到了前面：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> env<span class="token punctuation">-</span>pod

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  containers<span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">env</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> COUNT
        valueFrom<span class="token punctuation">:</span>
          configMapKeyRef<span class="token punctuation">:</span>
            name<span class="token punctuation">:</span> info
            key<span class="token punctuation">:</span> count
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GREETING
        valueFrom<span class="token punctuation">:</span>
          configMapKeyRef<span class="token punctuation">:</span>
            name<span class="token punctuation">:</span> info
            key<span class="token punctuation">:</span> greeting
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> USERNAME
        valueFrom<span class="token punctuation">:</span>
          secretKeyRef<span class="token punctuation">:</span>
            name<span class="token punctuation">:</span> user
            key<span class="token punctuation">:</span> name
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PASSWORD
        valueFrom<span class="token punctuation">:</span>
          secretKeyRef<span class="token punctuation">:</span>
            name<span class="token punctuation">:</span> user
            key<span class="token punctuation">:</span> pwd

    image<span class="token punctuation">:</span> busybox
    name<span class="token punctuation">:</span> busy
    imagePullPolicy<span class="token punctuation">:</span> IfNotPresent
    command<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;/bin/sleep&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;300&quot;</span><span class="token punctuation">]</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>这个Pod的名字是“env-pod”，镜像是“busybox”，执行命令sleep睡眠300秒，我们可以在这段时间里使用命令 <code>kubectl exec</code> 进入Pod观察环境变量。</p> <p>你需要重点关注的是它的“env”字段，里面定义了4个环境变量， <code>COUNT</code>、 <code>GREETING</code>、 <code>USERNAME</code>、 <code>PASSWORD</code>。</p> <p>对于明文配置数据， <code>COUNT</code>、 <code>GREETING</code> 引用的是ConfigMap对象，所以使用字段“ <strong>configMapKeyRef</strong>”，里面的“name”是ConfigMap对象的名字，也就是之前我们创建的“info”，而“key”字段分别是“info”对象里的 <code>count</code> 和 <code>greeting</code>。</p> <p>同样的对于机密配置数据， <code>USERNAME</code>、 <code>PASSWORD</code> 引用的是Secret对象，要使用字段“ <strong>secretKeyRef</strong>”，再用“name”指定Secret对象的名字 <code>user</code>，用“key”字段应用它里面的 <code>name</code> 和 <code>pwd</code> 。</p> <p>ConfigMap和Secret在Pod里的组合关系如图所示：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230609104657.png" alt="$uploadName" style="zoom:75%;"></center> <p>从这张图你就应该能够比较清楚地看出Pod与ConfigMap、Secret的“松耦合”关系，它们不是直接嵌套包含，而是使用“KeyRef”字段间接引用对象，这样，同一段配置信息就可以在不同的对象之间共享。</p> <p>弄清楚了环境变量的注入方式之后，让我们用 <code>kubectl apply</code> 创建Pod，再用 <code>kubectl exec</code> 进入Pod，验证环境变量是否生效：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl apply <span class="token parameter variable">-f</span> env-pod.yml
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> env-pod -- <span class="token function">sh</span>

<span class="token builtin class-name">echo</span> <span class="token variable">$COUNT</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$GREETING</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$USERNAME</span> <span class="token variable">$PASSWORD</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230609110504.png" alt="$uploadName" style="zoom:75%;"></center> <p>这张截图就显示了Pod的运行结果，可以看到在Pod里使用 <code>echo</code> 命令确实输出了我们在两个YAML里定义的配置信息，也就证明Pod对象成功组合了ConfigMap和Secret对象。</p> <p>以环境变量的方式使用ConfigMap/Secret还是比较简单的，下面来看第二种加载文件的方式。</p> <h4 id="_4-2-2-以volume的方式使用"><a href="#_4-2-2-以volume的方式使用" class="header-anchor">#</a> 4.2.2 以Volume的方式使用</h4> <p>Kubernetes为Pod定义了一个“ <strong>Volume</strong>”的概念，可以翻译成是“存储卷”。如果把Pod理解成是一个虚拟机，那么Volume就相当于是虚拟机里的磁盘。</p> <p>我们可以为Pod“挂载（mount）”多个Volume，里面存放供Pod访问的数据，这种方式有点类似 <code>docker run -v</code>，虽然用法复杂了一些，但功能也相应强大一些。</p> <p>在Pod里挂载Volume很容易，只需要在“ <strong>spec</strong>”里增加一个“ <strong>volumes</strong>”字段，然后再定义卷的名字和引用的ConfigMap/Secret就可以了。要注意的是Volume属于Pod，不属于容器，所以它和字段“containers”是同级的，都属于“spec”。</p> <p>下面我们先定义两个Volume，分别引用ConfigMap和Secret，名字是 <code>cm-vol</code> 和 <code>sec-vol</code>。有了Volume的定义之后，就可以在容器里挂载了，这要用到“ <strong>volumeMounts</strong>”字段，正如它的字面含义，可以把定义好的Volume挂载到容器里的某个路径下，所以需要在里面用“ <strong>mountPath</strong>”“ <strong>name</strong>”明确地指定挂载路径和Volume的名字。</p> <p>把“ <strong>volumes</strong>”和“ <strong>volumeMounts</strong>”字段都写好之后，配置信息就可以加载成文件了。下图表示他们之间的引用关系：</p> <center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230609111335.png" alt="$uploadName" style="zoom:75%;"></center> <p>你可以看到，挂载Volume的方式和环境变量又不太相同。环境变量是直接引用了ConfigMap/Secret，而Volume又多加了一个环节，需要先用Volume引用ConfigMap/Secret，然后在容器里挂载Volume，有点“兜圈子”“弯弯绕”。</p> <p><font color="blue">这种方式的好处在于：以Volume的概念统一抽象了所有的存储，不仅现在支持ConfigMap/Secret，以后还能够支持临时卷、持久卷、动态卷、快照卷等许多形式的存储，扩展性非常好。</font></p> <p>现在我把Pod的完整YAML描述列出来，然后使用 <code>kubectl apply</code> 创建它：</p> <div class="language-yaml line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br></div><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span> vol<span class="token punctuation">-</span>pod11

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  volumes<span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>vol
    configMap<span class="token punctuation">:</span>
      name<span class="token punctuation">:</span> info
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>vol
    secret<span class="token punctuation">:</span>
      secretName<span class="token punctuation">:</span> user1

  containers<span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /tmp/cm<span class="token punctuation">-</span>items
      name<span class="token punctuation">:</span> cm<span class="token punctuation">-</span>vol
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /tmp/sec<span class="token punctuation">-</span>items
      name<span class="token punctuation">:</span> sec<span class="token punctuation">-</span>vol

    image<span class="token punctuation">:</span> busybox<span class="token punctuation">:</span>latest
    name<span class="token punctuation">:</span> busy11
    imagePullPolicy<span class="token punctuation">:</span> IfNotPresent
    command<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;/bin/sleep&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;300&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>创建之后，我们还是用 <code>kubectl exec</code> 进入Pod，看看配置信息被加载成了什么形式：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>kubectl apply <span class="token parameter variable">-f</span> vol-pod.yml
kubectl get pod
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> vol-pod -- <span class="token function">sh</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><center><img src="https://blog-1310567564.cos.ap-beijing.myqcloud.com/img/20230609112424.png" alt="$uploadName" style="zoom:75%;"></center> <p>你会看到，ConfigMap和Secret都变成了目录的形式，而它们里面的Key-Value变成了一个个的文件，而文件名就是Key。(Key =&gt; 文件名，Value =&gt; 文件内容)</p> <p>因为这种形式上的差异，以Volume的方式来使用ConfigMap/Secret，就和环境变量不太一样。环境变量用法简单，更适合存放简短的字符串，而Volume更适合存放大数据量的配置文件，在Pod里加载成文件后让应用直接读取使用。</p> <h3 id="_4-3-小结"><a href="#_4-3-小结" class="header-anchor">#</a> 4.3 小结</h3> <p>以上学习了两种在Kubernetes里管理配置信息的API对象ConfigMap和Secret，它们分别代表了明文信息和机密敏感信息，存储在etcd里，在需要的时候可以注入Pod供Pod使用。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/n7301/blog/edit/master/docs/基础/20.云原生/15.Kubernetes入门实战课-罗剑锋/11.YAML、Pod、Job、CronJob、ConfigMap、Secret.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/06/10, 02:04:21</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/757154/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Kubernetes 的安装与基本架构</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/757154/" class="prev">Kubernetes 的安装与基本架构</a></span> <!----></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/757154/"><div>
            Kubernetes 的安装与基本架构
            <!----></div></a> <span class="date">06-04</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/1cc8db/"><div>
            初识容器
            <!----></div></a> <span class="date">05-30</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/850e00/"><div>
            开篇词
            <!----></div></a> <span class="date">05-30</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/Nrich-sunny" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>Nrich | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/blog/assets/js/app.73302609.js" defer></script><script src="/blog/assets/js/2.c02cd514.js" defer></script><script src="/blog/assets/js/58.52fb51c8.js" defer></script>
  </body>
</html>
